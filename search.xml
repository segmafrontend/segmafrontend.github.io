<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>redis延时队列</title>
    <url>/2021/05/10/redis%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="redis延时队列"><a href="#redis延时队列" class="headerlink" title="redis延时队列"></a>redis延时队列</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>利用redis的<code>Sorted Set</code>有序集合数据结构实现</p>
<ul>
<li>订单创建时，订单id和当前时间戳作为Sorted Set 的value和score</li>
<li>定时通过<code>zrangebyscore</code>返回指定score区间内的订单进行处理</li>
<li>通过<code>zrem</code>保证只有一个消费者能从Sorted Set中删除元素，删除成功消费者就可以执行任务了【<a id="more"></a>
<h2 id="取消未付款订单-确认收货实现"><a href="#取消未付款订单-确认收货实现" class="headerlink" title="取消未付款订单/确认收货实现"></a>取消未付款订单/确认收货实现</h2></li>
</ul>
<h3 id="加入队列"><a href="#加入队列" class="headerlink" title="加入队列"></a>加入队列</h3><ul>
<li>启动系统时，扫描未付款/已发货未收货的订单，将订单id和创建/发货时间加入队列</li>
<li>创建订单/发货时，添加当前订单的id和时间进入队列</li>
</ul>
<h2 id="移除队列"><a href="#移除队列" class="headerlink" title="移除队列"></a>移除队列</h2><ul>
<li>用户在设定时间范围内完成付款/收货，从队列中移除任务</li>
<li>到达设定时间，消费者删除任务然后执行任务(取消订单/确认收货)</li>
</ul>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript继承</title>
    <url>/2021/04/11/JavaScript%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="JavaScript继承"><a href="#JavaScript继承" class="headerlink" title="JavaScript继承"></a>JavaScript继承</h1><p>原型链</p>
<ul>
<li>普通对象有__proto__和constructor </li>
<li>函数也是对象，没有constructor，独有prototype属性</li>
</ul>
<p><img src="https://gitee.com/bean-sprout/image-bed/raw/master/images/251615513677_.pic_hd_123.png" alt="251615513677_.pic_hd_123" style="zoom:60%;"><br><a id="more"></a></p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>优点：原型链上的属性和方法都可以被继承</p>
<p>缺点：子类无法向父类传参</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 用于共享的方法和属性放到原型对象上</span></span><br><span class="line">Father.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'msg: '</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.type = <span class="string">'father'</span>;</span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于子类的属性和方法放到函数体内，不在原型链上</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father(); <span class="comment">// Son.prototype.__proto__ = Father.prototype</span></span><br><span class="line"><span class="comment">// Son.prototype.type = 'father';</span></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Son(<span class="string">'cz'</span>);</span><br><span class="line">p1.say(<span class="string">'may name is '</span>+p1.name+<span class="string">',my type is '</span>+p1.type);</span><br></pre></td></tr></table></figure>
<h2 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数/经典继承"></a>借用构造函数/经典继承</h2><p>优点：子类可以向父类传参</p>
<p>缺点：</p>
<ul>
<li>只能继承父类的实例方法和属性，无法继承原型属性和方法</li>
<li>使用call实际上是对父类的复制，每个新实例就会复制一份</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'father'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  Persion.call(<span class="keyword">this</span>, age);</span><br><span class="line">  <span class="comment">// 借用另一个构造函数的对象和方法的构造</span></span><br><span class="line">  <span class="comment">// 相当于 this.name = 'father'; this.age = age;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Son(<span class="number">18</span>); <span class="comment">// &#123; name: 'father', age: 18 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>结合原型链和经典继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'father'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123; <span class="built_in">console</span>.log(msg) &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, age); <span class="comment">// 借用Persion的属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Son(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>对象浅复制，增加一层__proto__的引用，Object.create()的实现</p>
<p>浅复制父类的原型对象作为子类的原型对象即可实现继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj1 = new Father();</span></span><br><span class="line"><span class="comment">// obj2 = createObj(obj1); // 基于obj1创建对象obj2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'son'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Son.prototype = Object.create(Father.prototype);</span></span><br><span class="line">Son.prototype = createObj(Father.prototype);</span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(son.name); <span class="comment">// son</span></span><br><span class="line">son.say(<span class="string">'hello'</span>); <span class="comment">// hello，继承了父类的原型方法</span></span><br></pre></td></tr></table></figure>
<h2 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h2><p>寄生：函数内返回返回对象，然后调用函数</p>
<p>对原型式继承二次封装，对原型式继承生成的对象进行扩展后返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatAnother</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = createObj(origin);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line">obj1 = &#123;</span><br><span class="line">  name: <span class="string">'obj1'</span></span><br><span class="line">&#125;</span><br><span class="line">obj2 = creatAnother(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// 'obj1'</span></span><br><span class="line">obj2.sayHi(); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>组合式继承中将父类的实例赋值给子类的原型对象的操作改为使用原型继承的方式浅复制一份父类的原型对象作为子类构造函数的原型对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line">Son.prototype = createObj(Father.prototype);</span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son.name); <span class="comment">// father</span></span><br><span class="line"><span class="built_in">console</span>.log(son.age); <span class="comment">// 18</span></span><br><span class="line">son.say(<span class="string">'hello'</span>); <span class="comment">// hello，继承了父类的原型方法</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块规范</title>
    <url>/2021/03/10/JavaScript%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="JavaScript模块规范"><a href="#JavaScript模块规范" class="headerlink" title="JavaScript模块规范"></a>JavaScript模块规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>Node.js和Webpack采用CommonJS编写，包括：</p>
<ul>
<li>模块引入(require)，用于加载模块</li>
<li>模块定义(exports)，对外的接口，加载模块其实就是加载module.exports属性(Node中每个模块exports即为module.exports，不要对exports重新赋值，只能添加属性)</li>
<li><p>模块标识(module)，在模块内代表当前模块</p>
<a id="more"></a>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3></li>
<li><p>独立作用域</p>
</li>
<li>同步引入</li>
<li>首次加载时require时运行，再次加载直接取缓存结果，要再次运行需要清除缓存</li>
</ul>
<h3 id="require命令"><a href="#require命令" class="headerlink" title="require命令"></a>require命令</h3><ul>
<li>加载并执行一个js文件，返回exports属性</li>
<li>参数可以为绝对路径、相对路径、文件名，文件名查找顺序node安装目录-&gt;当前目录node_modules-&gt;逐级向上的node_modules</li>
<li>require.main === module，可以在模块内判断模块是直接执行(true)还是require加载执行</li>
</ul>
<p><a href="/Users/chenzeng/Nextcloud/学习/require源码解析.md">require源码解析</a></p>
<h3 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h3><p>A加载B，B又加载A，那么B加载的将是A已经执行的部分，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.x = <span class="string">'a1'</span>;</span><br><span class="line"><span class="built_in">require</span>(./B.js);   <span class="comment">// 执行到这里就会加载B.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.x = <span class="string">'a2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.x = <span class="string">'b1'</span>;</span><br><span class="line"><span class="built_in">require</span>(./A.js);  <span class="comment">// 执行到这里只会加载A.js在加载B.js之前已经执行的第一句，返回一个&#123; x: 'a1' &#125;的对象</span></span><br><span class="line"><span class="built_in">module</span>.exports.x = <span class="string">'b2'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>Asynchronous Module Definition，异步模块定义，依赖前置原则，主要用于浏览器，RequireJS 在推广过程中对模块定义的规范化产出</p>
<h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>语法<figure class="highlight plain"><figcaption><span>[dependencies], factory)```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- id，模块标识</span><br><span class="line">- dependencies，依赖的模块的名称数组，依赖前置，先解决依赖才会执行factory方法</span><br><span class="line">- factory，工厂方法，初始化模块需要执行的函数或者对象，函数参数为依赖的模块，为对象时为模块的输出值</span><br><span class="line"></span><br><span class="line">### 加载模块</span><br><span class="line"></span><br><span class="line">需要引入require.js后使用require方法</span><br><span class="line"></span><br><span class="line">```require([dependencies], fucntion()&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    base: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ui.js</span></span><br><span class="line">define([<span class="string">'base.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    initPage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// page.js</span></span><br><span class="line">define([<span class="string">'base.js'</span>, <span class="string">'ui.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">base, ui</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// data.js</span></span><br><span class="line">define(&#123;</span><br><span class="line">  users: [],</span><br><span class="line">  numbers: []</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 兼容CommonJS规范</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> base = <span class="built_in">require</span>(<span class="string">'base.js'</span>);</span><br><span class="line">  <span class="built_in">module</span>.exports.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>Common Module Definition，通用模块定义，依赖就近原则，是SeaJS 在推广过程中被广泛认知。</p>
<h3 id="定义模块-1"><a href="#定义模块-1" class="headerlink" title="定义模块"></a>定义模块</h3><p>语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- factory，可以为字符串、对象、函数等</span><br><span class="line">- 为函数时就是模块的构造方法，function(require, exports, module) &#123;&#125;</span><br><span class="line">- 构造方法内require为同步加载，require.async(dependencies, function()&#123;&#125;)为异步加载</span><br><span class="line"></span><br><span class="line">## UMD</span><br><span class="line"></span><br><span class="line">兼容CommonJS和AMD规范</span><br><span class="line"></span><br><span class="line">## ES6</span><br><span class="line"></span><br><span class="line">- 静态化，ES6在编译时确定依赖关系而不是CommonJS和AMD的运行时，所以引入是不能是表达式</span><br><span class="line">- ES6的模块并不返回一个对象，通过export和import导出和引入</span><br><span class="line">- 提升效果，可以在引入前使用</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">// CommonJS</span><br><span class="line">let &#123; aaa, bbb &#125; = require(&apos;math&apos;);</span><br><span class="line">// 相当于</span><br><span class="line">let tmp = require(&apos;Math&apos;);</span><br><span class="line">let aaa = require.aaa;</span><br><span class="line">let bbb = require.bbb;</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">import &#123; aaa, bbb &#125; from &apos;math&apos;;</span><br><span class="line">// aaa, bbb必须和模块中导出的变量同名</span><br><span class="line">// export和import时都可以使用as对变量重命名，使用*表示整个模块</span><br><span class="line"></span><br><span class="line">// 模块内使用export default匿名导出，引用时可以自己命名模块</span><br><span class="line">import anyname from &apos;math&apos;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记</title>
    <url>/2020/09/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><p>一些js的基础知识<br><a id="more"></a></p>
<h2 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>传统前台-后台架构，各个项目相对独立，各自造各自的轮子，会使项目越来越臃肿，开发效率越来越低。出现大量重复开发，用户体验不统一，无法支持大规模的用户增长等问题。</p>
<p>为了提高开发效率，就提出将需求高度相似、通用程度高的业务由专门的团队负责规划和开发。也就是一个专门<code>造轮子</code>的部门。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>数据中台</strong>：统一对数据进行采集、数据集成、数据治理，统一标准和口径，让数据产生更多的价值。它的本质就是“数据仓库+数据服务中间件”，作为各个业务的数据源，为业务系统提供数据和计算服务。 <strong>业务中台</strong>：各个项目的共同业务整合成统一的服务平台，例如支付、用户等等 <strong>技术中台</strong>：为各个项目的开发人员提供通用的底层框架、引擎等 <strong>算法中台</strong>：为各个项目提供算法能力，搜索、推荐、图像识别等等</p>
<h2 id="Iaas基础设施服务-Paas平台服务-Saas软件服务"><a href="#Iaas基础设施服务-Paas平台服务-Saas软件服务" class="headerlink" title="Iaas基础设施服务\Paas平台服务\Saas软件服务"></a>Iaas基础设施服务\Paas平台服务\Saas软件服务</h2><p><strong>Iaas</strong>: 就是提供服务器、存储、网络等硬件支持服务 <strong>Paas</strong>: 软件部署平台，开发组只需要关心业务逻辑，不用关心底层实现 <strong>Saas</strong>: 软件服务，就是拿来即用的，不需要关心技术</p>
<h2 id="JavaScript相关"><a href="#JavaScript相关" class="headerlink" title="JavaScript相关"></a>JavaScript相关</h2><h3 id="执行上下文和执行栈"><a href="#执行上下文和执行栈" class="headerlink" title="执行上下文和执行栈"></a>执行上下文和执行栈</h3><p><strong>执行上下文</strong>：分全局和函数执行上下文，函数被调用时创建一个执行上下文，按被定义的顺序执行；不在函数中的代码均在全局上下文中执行，会创建一个window对象并让this指向这个对象。 <strong>执行栈</strong>: LIFO（后进先出），执行一段程序，先创建全局上下文，遇到一个函数调用就创建一个函数上下文压入执行栈顶部，引擎执行完一个函数就会将它弹出执行栈。</p>
<p>执行上下文分为<code>创建阶段</code>和<code>执行阶段</code></p>
<p>创建阶段分三个步骤：</p>
<ul>
<li>this的绑定</li>
<li>创建词法环境</li>
<li>创建变量环境</li>
</ul>
<h4 id="this的值"><a href="#this的值" class="headerlink" title="this的值"></a>this的值</h4><p>this的值取决于函数是如何被调用的，如果是被一个引用它的对象调用，那么this的值就是这个对象，否则就是全局对象或者undefiend（严格模式）。eg: obj.fn()的fn中的this就是obj，但是bar=obj.fn;bar()中的this就是全局了。</p>
<ul>
<li>由new调用：绑定到新创建的对象</li>
<li>由call或apply、bind调用：绑定到指定的对象，[].slice(argument)相当于arugment.slice()</li>
<li>由上下文对象调用：绑定到上下文对象</li>
<li>默认：全局对象 注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定this，继承外层函数调用的this绑定。</li>
</ul>
<h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><p>定义标识符（变量名称）和变量/函数之间的关联，一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。全局环境中外部环境引用为null，有内建的Object/Array等函数；函数环境中用户定义的变量存储在环境记录器中，外部环境引用为全局或者包含此函数的外部函数。每个函数对父级作用域的引用构成了作用域链。</p>
<h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><p>也是一个词法环境，和词法环境的区别就是用来记录var定义的变量，且初始值设为undefined。</p>
<p>函数的作用域取决于函数创建的位置，而不是执行的位置，就是静态作用域</p>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>编辑节点，代码执行前，所有变量和函数的声明会被添加到词法环境中，所有可以在声明的代码前访问到变量和函数。但是，声明和赋值是两步操作，声明会被提升，赋值不会</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">'chenz'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数内部没有声明就会向上查找到window.myname，后面语句中的变量声明会被提升，所以访问的是内部的myname</span></span><br><span class="line">  <span class="built_in">console</span>.log(myname); </span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>) &#123; <span class="keyword">var</span> mayname = <span class="string">'xxx'</span> &#125; <span class="comment">// 条件中的语句虽然不会被执行，但是声明会被识别到，只是没有被赋值</span></span><br><span class="line">  <span class="built_in">console</span>.log(myname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><blockquote>
<p>一个以隐式引用作为存储方式，以点操作符和属性访问语句作为语法糖的单向链表。</p>
</blockquote>
<h4 id="构造函数、实例对象、原型对象"><a href="#构造函数、实例对象、原型对象" class="headerlink" title="构造函数、实例对象、原型对象"></a>构造函数、实例对象、原型对象</h4><p>js中万物皆对象，分为普通对象和函数对象</p>
<ul>
<li>普通对象添加prototype属性就是原型对象</li>
<li>函数对象创建时就会自带prototype属性 构造函数就是设计图，实例对象就是生产的产品 实例对象的<em>proto</em>就是构造函数的prototype，也就是原型对象 实例对象的constructor就是<em>proto</em>的constructor，也就是原型对象的constructor</li>
</ul>
<p>原型prototype，就是给其它对象提供共享属性的对象，prototype 描述的是两个对象之间的某种关系（其中一个，为另一个提供属性访问权限）。 对象的__proto__属性实际上指向它的prototype对象的<em>proto</em>的get()方法。 每个对象都有一个__proto__属性，指向构造函数的prototype对象 每个对象都有自己的__proto__，构成了对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。</p>
<h4 id="原型的继承"><a href="#原型的继承" class="headerlink" title="原型的继承"></a>原型的继承</h4><p>Object.setPropertyOf 和 Object.create都可以实现原型的显式继承（即手动继承），区别在于：</p>
<ul>
<li>Object.setPrototypeOf，给我两个对象，我把其中一个设置为另一个的原型。</li>
<li>Object.create，给我一个对象，它将作为我创建的新对象的原型。 JavaScript 提供了隐式的原型继承方式，实现了下面这几个步骤：</li>
</ul>
<ol>
<li>创建空对象</li>
<li>设置该空对象的原型为另一个对象或者 null</li>
<li>填充该对象，增加属性或方法。</li>
</ol>
<p>通过 <code>new</code> 去创建 user 对象，可以通过 user.consturctor 访问到它的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// constructor函数</span><br><span class="line">function User(firstName, lastName) &#123;</span><br><span class="line">  this.firstName = fristName;</span><br><span class="line">  this.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line">const user = new User(&apos;zeng&apos;, &apos;chen&apos;);</span><br><span class="line">console.log(user.constructor === &apos;User&apos;); // true</span><br></pre></td></tr></table></figure>
<p>实际javasscript会隐式的完成完成创建对象、原型继承和属性初始化的过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user = &#123;&#125;;</span><br><span class="line">Object.setPrototypeOf(user, User.prototype);</span><br><span class="line">user.firstName = &apos;chenz&apos;;</span><br><span class="line">user.lastName = &apos;zeng&apos;;</span><br></pre></td></tr></table></figure>
<p>使用对象字面量创建对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  firstName: &apos;chen&apos;,</span><br><span class="line">  lastName: &apos;zeng&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user = new Object();</span><br><span class="line">user.firstName = &apos;chen&apos;;</span><br><span class="line">user.lastName = &apos;zeng&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>子类构造函数的原型指向父类构造函数 缺点:</p>
<ul>
<li>父类的属性被所有子类共享</li>
<li>创建子类时无法向父类传参</li>
</ul>
<h4 id="借用构造函数（经典继承）"><a href="#借用构造函数（经典继承）" class="headerlink" title="借用构造函数（经典继承）"></a>借用构造函数（经典继承）</h4><p>子类构造函数的this通过call指向父类构造函数，解决了原型链继承的问题 缺点：</p>
<ul>
<li>只能继承父类属性/方法，不能继承父类原型属性/方法</li>
<li>方法都在构造器中定义，每次创建实例都要创建一遍方法</li>
</ul>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>用原型链继承实现对原型属性/方法的继承，用借用构造函数来实现对实例属性/方法的继承 缺点：</p>
<ul>
<li>两次调用父类构造函数</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>又叫<code>静态工厂模式</code>，用于创建同一类产品的实例，根据传入的参数不同，创建的实例的属性就不同。 常用场景：用户权限（根据传入角色返回不同的实例）、vue-router（不同角色配置不同的路由）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Factory(name,age)&#123;</span><br><span class="line">    let person = &#123;&#125;;</span><br><span class="line">    person.name = name;</span><br><span class="line">    person.age = age;</span><br><span class="line">    person.say = function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br><span class="line">let tom = new Factory(&apos;Tom&apos;,&apos;10&apos;);</span><br><span class="line">let jerry = new Factory(&apos;Jerry&apos;,&apos;20&apos;);</span><br><span class="line">// ES6</span><br><span class="line">class Factory &#123;</span><br><span class="line">  //构造器</span><br><span class="line">  constructor(opt) &#123;</span><br><span class="line">    this.name = opt.name;</span><br><span class="line">    this.age = opt.age;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>抽象一个工厂用于创建一个工厂，将其成员对象的实例化推迟到子类中，子类可以重写父类接口方法以便创建时指定独自的对象类型，父类变为抽象类，不能被实例只能被继承。这样的好处是通用方法写在工厂函数中，不需要重复实现，不同个性化代码在子类中实现。 就是将简单工厂模式中的通用部分提取到一个父类中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(opt = &#123;&#125;) &#123;</span><br><span class="line">    if(new.target === User) &#123;</span><br><span class="line">      throw new Error(&apos;抽象类不能实例化!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.name = opt.name;</span><br><span class="line">    this.age = opt.age;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory extends User &#123;</span><br><span class="line">  constructor(opt) &#123;</span><br><span class="line">    super(opt);</span><br><span class="line">  &#125;</span><br><span class="line">  create(opt) &#123;</span><br><span class="line">    return new Factory(opt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>针对全局仅需一个对象的场景，如线程池、全局缓存、window 对象等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let CreateSingleton = (function()&#123;</span><br><span class="line">    let instance;</span><br><span class="line">    return function(name) &#123;</span><br><span class="line">        if (instance) &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">        this.name = name;</span><br><span class="line">        return instance = this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">CreateSingleton.prototype.getName = function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Winner = new CreateSingleton(&apos;Winner&apos;);</span><br><span class="line">let Looser = new CreateSingleton(&apos;Looser&apos;);</span><br><span class="line"></span><br><span class="line">console.log(Winner === Looser); // true</span><br><span class="line">console.log(Winner.getName());  // &apos;Winner&apos;</span><br><span class="line">console.log(Looser.getName());  // &apos;Winner&apos;</span><br></pre></td></tr></table></figure>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>定义了一种对象之间的一对多的关系，只要当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，解决了主体对象与观察者之间功能的耦合，即一个对象状态改变给其他对象通知的问题。常用的DOM事件绑定就是一种观察者模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 主体对象</span><br><span class="line">class SubjectObj &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.observers = []; // 观察者列表</span><br><span class="line">    this.internalState = 10; </span><br><span class="line">  &#125;</span><br><span class="line">  // 更新状态，触发观察者对象更新</span><br><span class="line">  notify(value) &#123;</span><br><span class="line">    this.internalState = value;</span><br><span class="line">    this.observers.forEach(observerFn =&gt; observerFn(value));</span><br><span class="line">  &#125;</span><br><span class="line">  // 注册观察者</span><br><span class="line">  registerObserver(observerFn) &#123;</span><br><span class="line">    this.observers.push(observerFn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h4><p>类似于观察者模式，但是多了一个中间层，增加了消息队列，改为异步推送。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>全局方法 –&gt; 对象封装 –&gt; 自调用函数(闭包) –&gt; script引入 好处：</p>
<ul>
<li>避免命名冲突</li>
<li>按需加载</li>
<li>更好维护</li>
<li>更好复用 问题：</li>
<li>请求过多</li>
<li>依赖关系混乱 为了解决这些问题，产生了模块化规范commonJS、AMD、CMD</li>
</ul>
<h4 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h4><p>Node采用的规范，一个文件就是一个模块，其中的变量、方法都是私有的。服务器端是同步加载的，客户端需要编译。 暴露模块：module.exports = value或者exports.xxx = value，module在模块内部代表模块本身 引入模块：require()，调用是读入并执行一段Javascript并查找exports属性，没找到会报错 输入的值为输出值的拷贝，如果是一个原始类型的值，模块内部值的变动就不会影响已经引入的值 加载模块为同步加载，只有加载完成了才能进行下一步操作，比较适合服务器端，因为文件都是本地加载</p>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>异步模块加载，RequireJS定义的规范，使用define方法进行模块的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 数组引入依赖，回调参数为引入的依赖</span><br><span class="line">// 依赖前置，一开始就引入了依赖</span><br><span class="line">define([module1, module2], function(module1, module2) &#123;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>延迟模块加载，与AMD的主要区别：</p>
<ul>
<li>AMD为提前执行，CMD为延迟执行</li>
<li>AMD为依赖前置，CMD为依赖就近</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">// requre用于引入依赖</span><br><span class="line">//引入依赖模块(同步)</span><br><span class="line">  var module2 = require(&apos;./module2&apos;)</span><br><span class="line">//引入依赖模块(异步)</span><br><span class="line">  require.async(&apos;./module3&apos;, function (m3) &#123;&#125;)</span><br><span class="line">// exports、module用于暴露模块</span><br><span class="line">exports.xxx = value;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>浏览器同源策略，“协议+域名+端口”必须相同，才能访问资源，三者中任意一个不同的情况访问资源都算作“跨域” 前端只能实现域名不同的跨域。 请求实际已经发出去了，只是返回时浏览器如果判断是跨域请求，就拦截了，所以无法完全阻止CSRF(跨站请求伪造) 不受跨域限制：</p>
<ul>
<li>img的src</li>
<li>link的href</li>
<li>script标签的src</li>
</ul>
<h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><p>利用script标签src不受跨域限制实现的跨域方案，动态获取json数据。 缺点：类似于同源的ajax，但是只支持get方法，有局限性，且容易遭受xss攻击(跨站脚本攻击) PS：xxs攻击，就是在本应是文本的地方输入/传入一段脚本，从而达到攻击的目的，</p>
<ul>
<li>存储型，持久，只要访问存储有恶意代码的数据，就会被攻击</li>
<li>反射型，非持久，只有访问特定的URL才会被攻击 危害：</li>
<li>劫持访问，跳转到其他页面</li>
<li>盗取cookie，实现无密码登录，可使用验证码、http-only cookie进行防范(禁止Javascript访问cookie)</li>
<li>配合CSRF，实现修改密码、银行转账等，可通过原密码校验、短信验证码等进行防范 防范：</li>
<li>过滤用户输入，对能实现xss的script、img、a等标签进行过滤</li>
<li>字符转义，让浏览器正确显示字符的同时不作为代码执行</li>
<li>限制用户输入，对于可预期的输入进行限制，例如邮箱、电话号码等</li>
</ul>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>深浅拷贝主要针对引用型数据，浅拷贝只拷贝引用不拷贝值</p>
<ul>
<li>= 赋值操作符是浅拷贝</li>
<li>JSON.stringify()和JSON.parse()转换可以实现深拷贝，但是不能拷贝属性是function/undefined/symbol</li>
<li>数组/对象自带的拷贝方法均是首层浅拷贝，只有第一层是深拷贝，二维就是浅拷贝了</li>
<li>只能递归才能实现真正的深拷贝</li>
</ul>
<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><ul>
<li>Event Table 用于注册异步回调ß</li>
<li>Event Queue 事件队列，主线程空闲时就会执行队列中的任务</li>
<li>主线程是唯一的，但是事件队列可以有多个，分宏任务和微任务，process.nextTick和Promise属于微任务，setTimeout本身属于宏任务在第一轮循环执行注册回调，然后微任务，然后第二轮执行宏任务执行回调。</li>
</ul>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化，就是将一个多参数的函数，转换成一系列使用一个参数的函数 作用：参数复用，对于多次调用同一个函数的情景，使用柯里化转换后的函数，相同的参数就不用重复传了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将普通函数柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// func.length表示func这个普通函数的参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// curriedFn(a)(b,c)的场景，concat后再次调用参数就是(a,b,c)了，走第一个if</span></span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>回调函数：a函数作为参数传给b函数，需要依赖b函数的调用，容易嵌套层数过多引起混乱 JavaScript异步解决方案 一个Promise对象有三种状态，只能从pendding到另外一种状态，且变更后凝固不再变化</p>
<ul>
<li>Pending 进行中</li>
<li>Fulfilled 已完成</li>
<li>Rejected 已拒绝 Promise对象 的then()方法接收一个函数参数，函数的两个参数分别是onFulfilled和onRejected，返回一个新的Promise(因为原来的Promise状态已经凝固) catch()方法是then(null/undefined, onRejected)的别名，捕获reject()和then的回调中的错误，错误会“冒泡”，最后的catch会捕获前面所有的错误 构造函数Promise()接收两个方法参数，resolve()方法将Pending变更为Fulfilled，reject()方法将Pendding变更为Rejected 构造函数中的代码将会立即执行，then()方法中的代码总是异步执行 立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务 Promise.allSettled()，接收数组，所有promise都finally才返回结果，只会变为Fulfilled，回调参数为数组</li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>就是声明各种纯函数，拼接成管道来完成任务</p>
<ul>
<li>数据不可变，不会修改已有的数据(外部变量)，新增进行处理</li>
<li>无状态，函数输出只取决于传入的参数，不依赖外部</li>
</ul>
<h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><p>基于流的打包工具，可以自动执行指定的任务 定义的是构建前端的流程，给图片压缩、文件压缩合并、启动server、版本控制等一系列任务设置顺序。</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>模块化打包工具，提供一个核心，通过loader（加载器）和plugins（插件）扩展核心，对资源进行处理，打包成符合生产环境部署的前端资源。可以将所有资源视为模块，如图片、视频、AMD模块、ES6模块、CSS等等，给模块设置依赖关系和规则实现打包，可以实现模块的按需加载。 动态import：import()是一个类函数的用法，但不是真正的函数，返回一个promise。编译时时遇到import()，webpack会对代码进行分割，生成一个chunk，再进行babel转换，运行时需要用到才会加载对应的chunk文件。可以通过命名chunk将不同的组件代码打包到同一个chunk中。</p>
<h4 id="loader和plugin"><a href="#loader和plugin" class="headerlink" title="loader和plugin"></a>loader和plugin</h4><p>loader主要负责转换代码，例如sass-loader、babel-loader、file-loader、url-loader等等</p>
<p> plugin主要负责处理代码，混淆、压缩、分包、提高效率等等，挂载wepack事件钩子触发，返回一个构造函数，例如html-webpack-plugin、UglifyJsPlugin(混淆)、HotModuleReplacementPlugin(热更新)等等</p>
<h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><p>流程：参数解析 -&gt; 入口文件 -&gt; loader编译 -&gt; -&gt; -&gt; 输出</p>
<ul>
<li><p>Compiler类，全局只会有一个它的实例，包含完整的webpack配置，负责文件的监听和编译的启动。</p>
</li>
<li><p>Compilation类，开发模式每一次文件变更就会生成一个新的Compilation实例，包含当前模块资源、生成的资源、变化的文件等</p>
<p><img src="https://i.loli.net/2020/06/01/ULJOKSmtrxyBqE3.png" alt="ezgif-7-8e65bfc6de58"></p>
</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>本来webpack只负责预编译模块，生成浏览器可以识别的代码；后来通过plugins也实现了gulp的代码处理工作。</p>
<h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h2><p>通过定义pipeline，其中设置多个job来配置</p>
<h3 id="CI-持续集成"><a href="#CI-持续集成" class="headerlink" title="CI - 持续集成"></a>CI - 持续集成</h3><p>提交代码合并入主分支前，自动进行一系列测试、打包构建等工作</p>
<h3 id="CD-持续部署"><a href="#CD-持续部署" class="headerlink" title="CD - 持续部署"></a>CD - 持续部署</h3><p>在集成了基础上，自动实现将代码部署到生产环境</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>无CDN，前端资源均存储在服务器上，访问用户多了服务器压力就会很大；而且不同地域访问收到网络速度的显示体验会相差很大。利用CDN(内容分发网络)将资源缓存到距离用户最近的运营商CDN节点中，就可以解决以上问题。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h3><p>后端解析url，根据服务器配置，返回html、json、图片等，浏览器通过返回的 Content-Type 来决定如何解析数据</p>
<h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>解析url，动态加载页面内容，</p>
<h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><p>修改url，会发送请求，造成页面的刷新，但是修改url的hash就不会，修改hash会触发hashchange事件，监听事件就可以实现动态加载页面内容了</p>
<h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><p>HTML5标准支持通过pushstate和replacestate修改url不会发送请求触发页面刷新，通过popstate事件监听实现动态加载页面内容 缺点：用户手动刷新页面会发送请求，可通过后端配置所有url重定向到根页面解决</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>MVVM框架，核心是双向数据绑定实现。采用数据劫持结合发布订阅模式，通过Object.defineProperty()劫持数据对象属性的getter和setter监听数据的变更，发布给订阅者触发对应的回调。包括Observer数据监听、Compile指令解析、Watcher观察器。</p>
<h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>浏览器渲染引擎工作流程：创建 DOM 树 —&gt; 创建 Style Rules -&gt; 构建 Render 树 —&gt; 布局 Layout -—&gt; 绘制 Painting 虚拟DOM就是将真实的DOM用js模拟，然后将DOM变更的对比，放到js层面去做，将多次更新合并为一次，并且只更新发生了变更的节点，最大限度的减少DOM操作，从而显著的提高性能</p>
<ul>
<li>手动操作DOM元素，每次操作都需要重新创建DOM树，非常浪费性能。</li>
<li>虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，再通过JS一次性attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量 Vue的diff算法和React的diff算法不同</li>
<li>Vue只对同一层的元素进行比对，复杂度较低</li>
</ul>
<h3 id="对象根属性添加"><a href="#对象根属性添加" class="headerlink" title="对象根属性添加"></a>对象根属性添加</h3><p>vue对data对象的响应式处理是在实例初始化时进行的，手动添加data对象的属性就无法修改其setter和getter 解决方案：提前声明属性；Vue.set()/Vm.$set()</p>
<h3 id="数组变更检测"><a href="#数组变更检测" class="headerlink" title="数组变更检测"></a>数组变更检测</h3><p>产生原因：Vue只对数组本身进行了相应式处理，不对内容处理，直接修改数组某一项的值或者length，Vue无法劫持数据，所以无法触发更新 解决方案：使用Vue.set()或者vm.$set()，或者变异方法</p>
<h3 id="3-0更新"><a href="#3-0更新" class="headerlink" title="3.0更新"></a>3.0更新</h3><p>基于Proxy的观察者，取代了基于Object.defineProperty的观察者，优点：</p>
<ul>
<li>可以检测属性的新增和删除</li>
<li>可以坚持数组索引的变化和length的变化</li>
<li>支持Map、Set等 重写了虚拟DOM，提速100%</li>
</ul>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>原理：</p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>构建DOM树，html解析 -&gt; style rules，生成样式表 -&gt; 构建render树，关联DOM和样式 -&gt; 布局layout，确定坐标 -&gt; 绘制</p>
<ul>
<li>html解析、css构建、render树构建三者是交叉执行的，一边加载一边解析一边渲染</li>
<li>每操作一次DOM就需要从头来一遍，所以开销较大</li>
</ul>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>CSS盒模型本质上是一个盒子，所有html元素都是盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容</p>
<ul>
<li>IE盒模型，width/height包含content、border、padding</li>
<li>W3C标准盒模型，width/height只包含content 可以通过设置box-sizing进行切换，border-box为IE盒模型，content-box为标准盒模型</li>
</ul>
<h3 id="块元素-行内元素"><a href="#块元素-行内元素" class="headerlink" title="块元素/行内元素"></a>块元素/行内元素</h3><ul>
<li>块元素新起一行，宽度默认100%；行内元素和其他元素在一行</li>
<li>块元素可以包含其他块元素/行内元素；行内元素只能包含文本/行内元素</li>
<li>块元素中高度、行高、上下边距等可以控制；行内元素不可以</li>
</ul>
<h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>常规流、浮动流、绝对定位流 常规流 格式化上下文，一块渲染区域，决定子元素的布局以及和其他元素的关系</p>
<ul>
<li>position为static/relative，并且float为none时，触发常规流</li>
<li>行内格式化上下文，从左到后排列</li>
<li>块级格式化上下文，从上到下排列 浮动流</li>
<li>float不为none触发浮动</li>
<li>浮动元素会影响行内格式化上下文，让行内元素围绕在浮动元素周围，撑大父元素，设置clear可以清除 绝对定位流</li>
<li>position为absolute/fixed，触发绝对定位流</li>
<li>盒从常规流中移除，根据left、right、top、bottom进行定位</li>
<li>absolute相对于上级元素中最近的一个relative、fixed、absolute的元素进行定位</li>
<li>fixed相对于viewport进行定位，一些让父级元素形成堆叠上下文的属性会导致相对于父级元素定位</li>
</ul>
<h3 id="块级格式化上下文-BFC-Block-Formatting-Context"><a href="#块级格式化上下文-BFC-Block-Formatting-Context" class="headerlink" title="块级格式化上下文(BFC - Block Formatting Context)"></a>块级格式化上下文(BFC - Block Formatting Context)</h3><p>一块独立的渲染区域，其中元素布局不受外界影响 触发方式：</p>
<ul>
<li>根元素</li>
<li>浮动元素</li>
<li>overflow为auto、scroll、hidden时，不为visible</li>
<li>display值为inline-block、flex、inline-flex、table、inline-table、table-cell、grid、inline-grid</li>
<li>绝对定位absolute、fixed</li>
<li>display: flow-root，无副作用，还不是完全支持 约束规则：</li>
<li>子元素从上到下一个接一个排列，各自占一行</li>
<li>相邻两个子元素会外边距折叠(两正取最大/两负取最小/正负取和)；两个BFC之间不会折叠</li>
<li>不会与float元素区域重叠</li>
<li>计算BFC高度时，float元素也参与计算 作用：</li>
<li>防止被float元素覆盖</li>
<li>包含浮动元素</li>
<li>第一个/最后一个子元素与非BFC父元素之间如果没有border/padding，margin将会溢出父元素，BFC可以解决</li>
<li>多列布局防止最后一个元素因为宽度四舍五入换行</li>
</ul>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>浮动元素会脱离常规文档流，不影响它前面的元素，它后面的行内元素会围绕浮动元素，将其包含在其中</p>
<ul>
<li>clear: both; 让元素周围都没有浮动元素，就会在浮动元素下方，可以间接达到撑开父元素的作用(父元素必须包含子元素) 常说的清除浮动其实是让浮动元素撑开父元素高度的意思，浮动元素会造成父元素高度塌陷，超出父元素的浮动元素会影响父级元素的兄弟元素的布局</li>
<li>父元素最后插入一个清除浮动的空元素/伪元素可以达到清除浮动同时撑开父元素高度的目的</li>
<li>父元素BFC，利用BFC会包含浮动元素的特性撑开父元素</li>
</ul>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul>
<li>已知高度，top: calc(50% - height/2);、top: 50%; margin-top: -height/2;、top: 0;bottom: 0;margin: auto;</li>
<li>高度未知，top: 50%; transform: translateY(-50%)</li>
<li>单行文本，line-height: 行高;</li>
<li>父元素为行内元素/table，vertical-align: middle;</li>
<li>父元素不要求高度，父元素padding: 100px 0;</li>
<li>图片，父元素设置line-height，图片设置vertical-align: middle;</li>
</ul>
<h3 id="像素、分辨率、缩放比"><a href="#像素、分辨率、缩放比" class="headerlink" title="像素、分辨率、缩放比"></a>像素、分辨率、缩放比</h3>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记</title>
    <url>/2020/05/15/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>在MVC的基础上实现了view-model，即视图与数据的双向绑定，视图只是数据的映射，所有逻辑都是对数据的修改，不用直接操作DOM。<br><a id="more"></a></p>
<h2 id="SPA单页应用"><a href="#SPA单页应用" class="headerlink" title="SPA单页应用"></a>SPA单页应用</h2><p>优点：</p>
<ul>
<li>具有桌面应用的即时反馈，无需刷新页面就可以交互，又有web的跨平台</li>
<li>后续操作无需重新从服务器获取静态资源，服务器压力较小</li>
<li>路由由前端控制，更好的前后端分离</li>
</ul>
<p>缺点：</p>
<ul>
<li>首屏加载资源较多，速度较慢（按需加载、懒加载）</li>
<li>需要手动实现导航的前进后退</li>
<li>不利于SEO（需手动优化）</li>
</ul>
<h2 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h2><p>new Vue() –&gt; init –&gt; $mount –&gt; compiler –&gt; render –&gt; vnode –&gt; patch –&gt; DOM</p>
<h2 id="常用题目"><a href="#常用题目" class="headerlink" title="常用题目"></a>常用题目</h2><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>父组件使用用prop和子组件进行通信，父级prop更新传递给子组件进行更新，反之则不行。子组件中不能修改prop，只能通过$emit一个事件通知父组件，由父组件更新prop来修改。</p>
<h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><ul>
<li>计算属性，依赖于参与计算的其他属性值，会对计算结果进行缓存，依赖的值发生变更才会重新计算，主要为了获取到最新的值。</li>
<li>watch，当某个属性值发生变化时，触发对应的回调。更多的是在数据变化是执行异步操作/复杂操作， 而不是为了获取最新的值。</li>
</ul>
<h3 id="对象变更检测"><a href="#对象变更检测" class="headerlink" title="对象变更检测"></a>对象变更检测</h3><p>Vue是在初始化实例时对data对象上的property执行getter/setter转换实现检测变更的，直接添加根级别的property将无法触发更新。</p>
<p>可以通过以下方式添加：</p>
<ul>
<li>Vue.set(vm.someObject, b, 2)/vm.$set(vm.someObject, b, 2)</li>
<li>this.someObject = Object.assign({}, this.someObject, { b: 2 })</li>
</ul>
<h3 id="数组变更检测"><a href="#数组变更检测" class="headerlink" title="数组变更检测"></a>数组变更检测</h3><p>直接修改数组中一项的值，或者修改数组的length，Vue无法检测到数据的变更。因为Vue是通过数据劫持实现监控数据的，只对数组本身进行了处理，对内容并没有处理。</p>
<p>通过以下方式Vue可以检测到变更：</p>
<ul>
<li>变异方法，Vue对数组的方法进行了处理，调用时即可检测变更，eg：splice、push、shift、pop、slice等</li>
<li>Vue.set()/vm.$set()</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>创建实例 </li>
<li>初始化事件/生命周期</li>
<li>初始化注入/校验，data和methods初始化完毕</li>
<li>编译模板，生成模板</li>
<li>挂载实例，创建vm.$e并l替换el</li>
<li>销毁实例</li>
</ul>
<h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><ul>
<li>beforeCreate，</li>
<li>created，最早可以操作data和methods的地方</li>
<li>beforeMount</li>
<li>mounted，初始化完毕，渲染真是dom</li>
<li>beforeUpdate，data变成最新值，但是还没有更新到dom</li>
<li>updated</li>
<li>beforeDestroy，data、methods、指令、过滤器、计算属性等可用</li>
<li>destroyed</li>
</ul>
<h3 id="父组件监听子组件钩子"><a href="#父组件监听子组件钩子" class="headerlink" title="父组件监听子组件钩子"></a>父组件监听子组件钩子</h3><p>方法一：手动在子组件钩子中$emit</p>
<p>方法二：父组件使用@hook:mounted就可以实现</p>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>抽象组件，不会渲染任何DOM，动态组件<code>&lt;component :is=&quot;currentComponet&quot;&gt;&lt;/component&gt;</code>切换时每次都会重新渲染组件，无法保存状态，使用keep-alive组件包裹，就可以实现状态的保存。</p>
<ul>
<li>对应activated和deactivated两个钩子函数</li>
<li>使用include/exclude属性传入正则/字符串，就可以设置哪些组件缓存/不缓存</li>
</ul>
<h3 id="为什么组件中data是一个函数返回一个对象，而new-Vue-中data是一个对象"><a href="#为什么组件中data是一个函数返回一个对象，而new-Vue-中data是一个对象" class="headerlink" title="为什么组件中data是一个函数返回一个对象，而new Vue()中data是一个对象"></a>为什么组件中data是一个函数返回一个对象，而new Vue()中data是一个对象</h3><p>因为对象是引用类的数据，组件复用时，如果是data 是对象，修改单个组件时就会影响其他组件的值。</p>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>语法糖，例如input元素使用v-model相当于使用value和input事件修改value</p>
<p>用在组件上，默认使用名为value的prop和input的自定义事件</p>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><ul>
<li>父 -&gt; 子，prop/ref/$children</li>
<li>子 -&gt; 父，$emit/$parent</li>
<li>兄弟，EventBus</li>
<li>隔代，$attrs/$listeners，子组件上v-bind=”$attrs”会向下传递props属性中未获取的父组件传下来的props;$listeners包含了作用于当前组件的所有事件</li>
<li>隔代，provide/inject，provide传递数据，inject获取数据</li>
<li>Vuex，状态管理模式，state存储状态，getter计算状态，mutation/action可预测的变更状态，响应式</li>
</ul>
<h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><p>服务端渲染，Vue在服务端渲染html页面推送到浏览器进行展示</p>
<ul>
<li>更好的SEO</li>
<li>更快的首屏加载</li>
<li>只支持beforeCreate和created两个钩子</li>
<li>占用更多的服务器资源</li>
</ul>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><ul>
<li>hash模式，修改url的hash值（location.hash）实现跳转，hashchange更改页面内容</li>
<li>history模式，HTML5 History API，pushState和replaceState修改url不会引起页面刷新，需要配置后台避免手动刷新404</li>
<li>abstract模式，不依赖于浏览器，通过数组模拟浏览器历史记录和功能</li>
</ul>
<h3 id="双向绑定实现"><a href="#双向绑定实现" class="headerlink" title="双向绑定实现"></a>双向绑定实现</h3><ul>
<li>Observer监听器，对数据对象data进行遍历，使用Object.definePropery()添加getter和setter实现数据劫持，对data 的属性进行修改时就会触发setter</li>
<li>Compiler解析器，解析模板指令，将模板中的变量替换为数据，解析指令给对应节点绑定更新函数，添加数据订阅器</li>
<li>Watcher订阅者，订阅Observer中的数据变更，找到对应的更新函数并调用</li>
<li>Dep订阅器，收集订阅者</li>
</ul>
<h3 id="数组变化检测"><a href="#数组变化检测" class="headerlink" title="数组变化检测"></a>数组变化检测</h3><p>通过重写数组的push、pop、shift、unshift、splice、sort、reverse等方法实现数据劫持，不能修改Array.prototype上的方法，通过一个对象使用Object.create()原型继承的方式继承Array.prototype，将变异方法添加到新对象上，然后将data的数组属性的<strong>proto</strong>设置为新对象即可。</p>
<h3 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h3><p>优点：</p>
<ul>
<li>短时间内多次修改操作可以合并成一次，较少渲染成本</li>
<li>框架的虚拟DOM对呀修改DOM进行了性能优化，比手动修改DOM开销更小</li>
<li>对比修改前后的虚拟DOM计算差异，避免渲染整个DOM树</li>
<li>实现双向数据绑定，修改数据即可自动修改视图，减少开发成本</li>
<li>跨平台，纯JS实现，不依赖浏览器，可以实现服务端渲染、weex开发等等</li>
</ul>
<p>缺点：</p>
<ul>
<li>多了一次运算，增加开销</li>
<li>虚拟DOM需要适配上层API，无法做到极致的性能优化</li>
</ul>
<h3 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理"></a>虚拟DOM实现原理</h3><ul>
<li>解析html，用js对象模拟DOM树，对真是DOM进行抽象</li>
<li>dff算法，比较修改前后DOM树的差异</li>
<li>patch算法，将差异部分应用到真正的DOM树</li>
</ul>
<h3 id="Key的作用"><a href="#Key的作用" class="headerlink" title="Key的作用"></a>Key的作用</h3><p>vnode的唯一标记，可以更准确、更快的diff操作</p>
<ul>
<li>解决不需要就地复用的场景</li>
<li>直接通过key取节点比遍历更快</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>v-if和v-show</li>
<li>v-for和v-if混用</li>
<li>computed和watch</li>
<li>长列表优化，无限滚动/可见区域渲染</li>
<li>销毁事件</li>
<li>懒加载，路由、图片、组件等</li>
<li>三方插件按需引入</li>
<li>CDN</li>
<li>压缩，webpack、nginx</li>
<li>组件化</li>
<li>sourceMap优化</li>
<li>浏览器缓存机制优化</li>
</ul>
<h3 id="使用过程中遇到的最大的问题"><a href="#使用过程中遇到的最大的问题" class="headerlink" title="使用过程中遇到的最大的问题"></a>使用过程中遇到的最大的问题</h3><ul>
<li>数组变更检测，变异方法解决</li>
<li>异步回调中this指向问题，箭头函数/变量获取this</li>
<li>setInterval销毁</li>
</ul>
<h2 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a>3.0</h2><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>创建一个代理替代一个对象，对目标对象的所有操作都可以在代理中进行拦截，对数组同样有效。</p>
<ul>
<li>可以直接检测对象，而不是对象的属性，可以检测到对象的添加和删除</li>
<li>检测数组的索引和长度的变更</li>
<li>支持Set、Map、WeakMap和WeakSet</li>
</ul>
<h3 id="改用typescript，对ts更友好"><a href="#改用typescript，对ts更友好" class="headerlink" title="改用typescript，对ts更友好"></a>改用typescript，对ts更友好</h3>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS硬盘休眠</title>
    <url>/2020/04/13/%E7%A1%AC%E7%9B%98%E4%BC%91%E7%9C%A0/</url>
    <content><![CDATA[<h2 id="hdparm"><a href="#hdparm" class="headerlink" title="hdparm"></a>hdparm</h2><p>设置磁盘自动进入<code>stanby</code>的时间，可以达到节能的目的,但是如果程序频繁访问磁盘，会导致磁盘频繁的stanby然后唤醒，非常容易损伤磁盘<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看磁盘当前电源状态</span></span><br><span class="line">hdparm -C /dev/sdb1</span><br><span class="line"><span class="comment"># 设置磁盘进入stanby时间，value*5=分钟数</span></span><br><span class="line"><span class="comment"># 设置磁盘闲置一分钟进入stanby</span></span><br><span class="line">hdparm -S 12 /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<h2 id="smartctl"><a href="#smartctl" class="headerlink" title="smartctl"></a>smartctl</h2><p>检查磁盘的<code>smart</code>信息，详细解释看<a href="https://www.cnblogs.com/xqzt/p/5512075.html" target="_blank" rel="noopener">这里</a>，主要看<code>Load/Unload Cycle Count</code>表示磁头加载/卸载的次数，新台式机硬盘设计寿命一般可达一百万次。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl -a /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>西部数据硬盘主要为windows/macOS设计，默认8s没有操作就会自动将磁头卸载，已达到节能降低噪音的目的，但是作为NAS存储盘使用，并不会持续访问硬盘，而是某些服务间隔几秒访问一次，就会导致磁头不停的加载卸载，大约3分钟就会增加1次。算下来一个硬盘只能使用<code>231天</code>。<br>为了延长硬盘寿命，有以下两种方案：</p>
<ol>
<li>控制系统服务访问硬盘，按需访问。</li>
<li>增加硬盘自动卸载的间隔时间到几分钟。</li>
</ol>
<p>因为需要使用<code>nextcloud</code>私有云服务，方案一实现起来很困难，所以采用方案二，安装<code>idle3-tools</code>软件修改硬盘卸载时间。</p>
<h2 id="idle3-tools"><a href="#idle3-tools" class="headerlink" title="idle3-tools"></a>idle3-tools</h2><p>这是一个替代官方<code>wdidle3.exe</code>的第三方软件，专门用于修改西部数据硬盘的磁头自动停靠时间。附: <a href="http://idle3-tools.sourceforge.net/" target="_blank" rel="noopener">官方文档</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前值</span></span><br><span class="line">idle3ctl -g /dev/sdb1</span><br><span class="line"><span class="comment"># 修改值为300s，1-128为0.1秒一个单位，129-255为30秒一个单位</span></span><br><span class="line">idle3ctl -s 138 /dev/sdb1</span><br><span class="line"><span class="comment"># 禁用自动停靠</span></span><br><span class="line">idle3ctl -d /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>修改成功后需要完全关闭机器，再打开才能生效。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2020/02/29/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><code>ctrl+b</code>向上翻页<br><code>ctrl+f</code>向下翻页<br><code>v</code>进入视图模式，实现多选<br><code>ctrl+v</code>进入列视图模式，实现多列选中<br><code>I</code>列视图模式多列输入，需要返回命令模式才会应用<br><a id="more"></a></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>压缩<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvf abc.tar abc</span><br></pre></td></tr></table></figure></p>
<p>解压缩<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf abc.tar</span><br></pre></td></tr></table></figure></p>
<p><code>du -h --max-depth=0 folder</code>查看文件夹大小</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>合并文件夹<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -av folderA folderB</span><br><span class="line">rm -rf folderA</span><br></pre></td></tr></table></figure></p>
<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p><code>history</code>查询输入命令历史<br><code>history number</code>最近的多少条记录<br><code>!!</code>执行上一条命令<br><code>!numer</code>执行指定命令<br><code>ctrl+r</code>搜索历史记录，搜索后继续按<code>ctrl+r</code>可翻页ß<br><code>ctrl+u</code>清空当前输入<br><code>nohup command &amp;</code>nohup表示退出后仍然运行，&amp;表示后台运行,<a href="https://www.jianshu.com/p/cddb2e27a594" target="_blank" rel="noopener">文档</a><br><code>jobs -l</code>查看当前终端后台进程<br><code>ps -aux</code>查看进程,a所有程序,u用户为主,x不区分终端,<a href="https://www.cnblogs.com/baby123/p/6477429.html" target="_blank" rel="noopener">文档</a><br><code>ctrl+z</code>进程放到后台并暂停<br><code>bg &lt;number&gt;</code>继续后台已经暂停的进程<br><code>fg &lt;number&gt;</code>后台进程放到前台</p>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p><code>yum install -y &lt;软件名&gt;</code>安装<br>卸载软件</p>
<ol>
<li><code>yum history list &lt;软件名&gt;</code>查看安装记录，变更数为依赖数</li>
<li><code>yum history undo &lt;ID&gt;</code>卸载软件以及依赖<br><code>top</code>查看系统状态，按<code>m</code>以内存排序<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><code>docker system df</code>查看docker镜像容器磁盘占用，<code>-v</code>参数查看详情</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RN填坑记录</title>
    <url>/2019/09/19/RN%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li>网络调试，开启网络调试后，发送请求无法正常返回数据，response为空，需要关闭后恢复正常</li>
<li>安卓获取权限，在<code>AndroidManifest</code>中声明的，在android 6.0之前直接就可以获取，在之后一些敏感的权限（定位、文件、相机等）需要先声明然后使用<code>PermissionsAndroid</code>动态获取（弹窗让用户确认）。可根据用户是否选择不再提醒要求用户到系统设置中修改。</li>
<li>formData无法使用，需要在<code>app.js</code>中加入以下代码<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">global.FormData = global.originalFormData</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="MAC开发RN项目"><a href="#MAC开发RN项目" class="headerlink" title="MAC开发RN项目"></a>MAC开发RN项目</h2><h3 id="用xCode需要打开-xcworkspace文件"><a href="#用xCode需要打开-xcworkspace文件" class="headerlink" title="用xCode需要打开.xcworkspace文件"></a>用xCode需要打开<code>.xcworkspace</code>文件</h3><h3 id="无法找到模拟器错误"><a href="#无法找到模拟器错误" class="headerlink" title="无法找到模拟器错误"></a>无法找到模拟器错误</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error Could not find <span class="string">"iPhone X"</span> simulator</span><br></pre></td></tr></table></figure>
<p>运行时指定模拟器版本解决<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">react-native run-ios --simulator=<span class="string">"iPhone 11"</span></span><br></pre></td></tr></table></figure></p>
<p>react-native run-android报错<code>spawnSync ./gradlew EACCES</code><br>通过修改./gradlew文件的权限解决<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 755 android/.gradlew</span><br></pre></td></tr></table></figure></p>
<p><code>pod install</code>报错443，执行下面语句解决<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod repo remove trunk &amp;&amp; pod install</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Undefined symbols <span class="keyword">for</span> architecture x86_64</span><br></pre></td></tr></table></figure>
<p>无法启动react-native-config，无法使用<code>pod install</code>安装，需要删除Podfile中react-native-config相关行，然后手动link<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Podfile</span></span><br><span class="line">- pod <span class="string">'react-native-config'</span>, :<span class="function"><span class="params">path</span> =&gt;</span> <span class="string">'../node_modules/react-native-config'</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react-native-config</span><br><span class="line">react-native link react-native-config</span><br><span class="line">react-native run-ios</span><br></pre></td></tr></table></figure>
<p>native module cannot be null，某些第三方包(<code>react-native-amap3d</code>)用到了源生模块，但是没有正确的配置造成的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppDelegate.m</span></span><br><span class="line">#import &lt;AMapFoundationKit/AMapFoundationKit.h&gt;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">	[AMapServices sharedServices].apiKey = @<span class="string">"你的高德 Key"</span>;</span><br><span class="line"></span><br><span class="line">	RCTBrige ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>安装centOS7搭建NAS记录</title>
    <url>/2019/09/19/%E5%AE%89%E8%A3%85centos7%E6%90%AD%E5%BB%BANAS%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="下载ISO镜像"><a href="#下载ISO镜像" class="headerlink" title="下载ISO镜像"></a>下载ISO镜像</h2><p>镜像分为标准、最小(Minimal)、桌面(Gnome)、网络(NetInstall)、完整(Everything)等几个版本，带live 的版本只会在内存中运行不能安装到硬盘。附：<a href="https://www.jianshu.com/p/c17d34dfd7f9" target="_blank" rel="noopener">版本说明</a></p>
<h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>U盘启动分为BIOS和UEFI两种方式</p>
<ul>
<li>BIOS启动会展示老毛桃的更多菜单</li>
<li>UEFI模式只能选择PE进入<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2>会出现无法识别安装文件的问题，需要先查看U盘的盘符，然后修改配置指定盘符。开机进入安装选择界面，UEFI模式按<code>e</code>，BIOS模式按<code>tab</code>进入选项，修改如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img linux dd quiet</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>之后就会展示盘符，LABEL为CentOS的就是安装盘了，记下并重启，再次进入安装选项，修改如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:/dev/&lt;盘符&gt; quiet</span><br></pre></td></tr></table></figure></p>
<p>安装完成后需要进行的工作</p>
<ul>
<li>设置网络，默认未开启</li>
<li>配置yum以及各种源</li>
<li>安装各种软件<h2 id="frpc"><a href="#frpc" class="headerlink" title="frpc"></a>frpc</h2>利用frpc实现内网穿透，通过外网访问内网服务<br>配置<code>frpc.ini</code>，可以通过配置<code>host_header_rewrite</code>实现子域名访问服务，具体代码：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[nextcloud]</span><br><span class="line"><span class="built_in">type</span> = http</span><br><span class="line">local_ip = 192.168.0.168</span><br><span class="line">local_port =  8080</span><br><span class="line">remote_port = 8780</span><br><span class="line">subdomain = nextcloud</span><br><span class="line">host_header_rewrite = nextcloud.vpn.aizys.win:8780</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="nextcloud"><a href="#nextcloud" class="headerlink" title="nextcloud"></a>nextcloud</h3><p>安卓APP官方正式版不支持自动上传历史图片，只能上传新增文件<br>可下载github上的测试版实现，详细参考<a href="https://github.com/nextcloud/android/pull/4788#issuecomment-549124896" target="_blank" rel="noopener">github</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Apollo接入RN记录</title>
    <url>/2019/09/11/Apollo%E6%8E%A5%E5%85%A5RN%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>接入RN主要通过<code>@apollo/react-hooks</code>的ApolloProvider进行注册<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApolloProvider &#125; <span class="keyword">from</span> <span class="string">'@apollo/react-hooks'</span>;</span><br><span class="line"><span class="keyword">import</span> ApolloClient <span class="keyword">from</span> <span class="string">'./src/apollo/ApolloClient'</span>;</span><br><span class="line"><span class="keyword">import</span> AppContainer <span class="keyword">from</span> <span class="string">'./src/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ApolloProvider client=&#123;ApolloClient&#125;&gt;</span><br><span class="line">      &lt;AppContainer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/ApolloProvider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>用<code>@apollo/react-hoc</code>的高阶组件graphql实现查询/突变并将结果注入RN组件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'@apollo/react-hoc'</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> graphql(gql<span class="string">`...`</span>)(component);</span><br></pre></td></tr></table></figure></p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><ul>
<li>JS调试，使用自带的<code>Remote JS Debugging</code>工具</li>
<li>样式调试，安装<a href="https://github.com/jhen0409/react-native-debugger" target="_blank" rel="noopener">React Native Debugger</a></li>
</ul>
<h2 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h2><ul>
<li><p>单个组件实现多个查询/突变，官方文档写的compose方法无法调用。查询源码发现最新版本代码已经移除了compost方法，需要自己写一个。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compose(...funcs: <span class="built_in">Function</span>[]) &#123;</span><br><span class="line">  <span class="keyword">const</span> functions = funcs.reverse();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args: any[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [firstFunction, ...restFunctions] = functions;</span><br><span class="line">    <span class="keyword">let</span> result = firstFunction.apply(<span class="literal">null</span>, args);</span><br><span class="line">    restFunctions.forEach(<span class="function"><span class="params">fnc</span> =&gt;</span> &#123;</span><br><span class="line">      result = fnc.call(<span class="literal">null</span>, result);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>.graphql文件无法使用。由于RN没有使用webpack，无法通过loader读取。需要安装<code>babel-plugin-import-graphql</code>这个插件，这个插件使用export导出，引入方式和loader不同</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; customers &#125; <span class="keyword">from</span> <span class="string">'./login.graphql'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>resolvers中引入的变量无法正常使用，且不报错。原因：不能使用和重名的变量，报错只能通过查询返回的props.data.error查看</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; customers <span class="keyword">as</span> customersQuery &#125; <span class="keyword">from</span> <span class="string">'./login.graphql'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地resolvers处理带参数的查询，需要先不传参数获取所有结果，然后根据传入变量筛选后返回，<code>readQuery</code>的variables无法查询数组。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
      <tags>
        <tag>Apollo</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Apollo接入Vue记录</title>
    <url>/2019/09/06/Apollo%E6%8E%A5%E5%85%A5Vue%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>经过试用，Apollo接入到Vue通过<a href="https://vue-apollo.netlify.com/zh-cn/" target="_blank" rel="noopener">vue-apollo</a>这个库实现，具体接入方式有三种：</p>
<ul>
<li>JS API</li>
<li>Vue组件</li>
<li>Apollo组件<a id="more"></a>
<h2 id="JS-API"><a href="#JS-API" class="headerlink" title="JS API"></a>JS API</h2>实现方法：</li>
</ul>
<ol>
<li>单独文件创建ApolloClient实例，在main.js引入，同时在api文件中引入实例</li>
<li><p>通过.graphql写查询语句</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query HelloWorld &#123;</span><br><span class="line">    hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置webpack读取.graphql文件</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// GraphQL Loader</span></span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">'graphql'</span>)</span><br><span class="line">      .test(<span class="regexp">/\.graphql$/</span>)</span><br><span class="line">      .use(<span class="string">'graphql-tag/loader'</span>)</span><br><span class="line">      .loader(<span class="string">'graphql-tag/loader'</span>)</span><br><span class="line">      .end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ApolloClient实例的query方法新建查询，会返回一个Promise对象</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// login.js</span></span><br><span class="line"><span class="keyword">import</span> ApolloClient <span class="keyword">from</span> <span class="string">'./ApolloClient'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> loginGql <span class="keyword">from</span> <span class="string">'./login.graphql'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getHello = <span class="function">(<span class="params">params</span>) =&gt;</span> ApolloClient.query(&#123;<span class="attr">query</span>: loginGql.HelloWorld&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过包装传入参数实现类axios效果</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getHello &#125; <span class="keyword">from</span> <span class="string">'login.js'</span></span><br><span class="line"></span><br><span class="line">getHello().then().catch()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>优点</strong>: 可以实现类似axios的封装，在vue组件和js代码中使用方法同axios，从axios迁移成本较低<br><strong>缺点</strong>: 通过ApolloClient实现查询，在vue组件中无法通过<code>$apollo</code>获取到查询相关信息，也就没法利用apollo的loading等特性</p>
<h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><h3 id="新增数据后重新请求已更新本地缓存"><a href="#新增数据后重新请求已更新本地缓存" class="headerlink" title="新增数据后重新请求已更新本地缓存"></a>新增数据后重新请求已更新本地缓存</h3><p>使用<code>refetchQueries</code>属性实现<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$apollo.mutate(&#123;</span><br><span class="line">        <span class="comment">// 查询语句</span></span><br><span class="line">        mutation: gql<span class="string">`mutation ($name: String!, $phone: String!) &#123;</span></span><br><span class="line"><span class="string">        createCustomer(name: $name, phone: $phone) &#123;</span></span><br><span class="line"><span class="string">          id</span></span><br><span class="line"><span class="string">          name</span></span><br><span class="line"><span class="string">          phone</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;`</span>,</span><br><span class="line">        <span class="comment">// 参数</span></span><br><span class="line">        variables: &#123;</span><br><span class="line">          name: <span class="string">"test"</span>,</span><br><span class="line">          phone: <span class="string">`189<span class="subst">$&#123;<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">100000000</span>)&#125;</span>`</span></span><br><span class="line">        &#125;,</span><br><span class="line">        refetchQueries: [&#123; <span class="attr">query</span>: loginGql.getCustomers &#125;]</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="修改数据后自动更新缓存"><a href="#修改数据后自动更新缓存" class="headerlink" title="修改数据后自动更新缓存"></a>修改数据后自动更新缓存</h3><p>要求后台更新后返回新的数据对象，只要<code>id/__typename</code>能匹配上，就会自动更新，不然就只有在<code>update</code>字段中使用<code>readQuery和writeQuery</code>手动更新缓存<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$apollo.mutate(&#123;</span><br><span class="line">      <span class="comment">// 查询语句</span></span><br><span class="line">      mutation: gql<span class="string">`mutation ($label: String!) &#123;</span></span><br><span class="line"><span class="string">        addTag(label: $label) &#123;</span></span><br><span class="line"><span class="string">          id</span></span><br><span class="line"><span class="string">          label</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;`</span>,</span><br><span class="line">      <span class="comment">// 参数</span></span><br><span class="line">      variables: &#123;</span><br><span class="line">        label: newTag,</span><br><span class="line">      &#125;,</span><br><span class="line">	  update: <span class="function">(<span class="params">store, &#123; data: &#123; addTag &#125; &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 从缓存中读取这个查询的数据</span></span><br><span class="line">        <span class="keyword">const</span> data = store.readQuery(&#123; <span class="attr">query</span>: TAGS_QUERY &#125;)</span><br><span class="line">        <span class="comment">// 将变更中的标签添加到最后</span></span><br><span class="line">        data.tags.push(addTag)</span><br><span class="line">        <span class="comment">// 将数据写回缓存</span></span><br><span class="line">        store.writeQuery(&#123; <span class="attr">query</span>: TAGS_QUERY, data &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
      <tags>
        <tag>Apollo</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue cli 3.0项目优化总结Vue Router懒加载+按需引入+高可用CDN</title>
    <url>/2019/02/21/Vue%20CLI%203.0%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93Vue%20Router%E6%87%92%E5%8A%A0%E8%BD%BD+%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5+%E9%AB%98%E5%8F%AF%E7%94%A8CDN/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用Vue.js构建的单页面应用（SPA - single page application），需要引入很多的库，包括自家的router、vuex等，第三方的axios、loadash等等，不做任何配置打包之后的文件就有10M+，在第一次载入页面的时候需要加载完整的应用代码，会出现长时间的白屏，用户体验极差。</p>
<p>我们的目标就是减少包体积、提升加载速度，同时保证可用性、维护性、不侵入业务代码。</p>
<p>具体的优化方法包括：</p>
<ul>
<li>Vue Router 懒加载</li>
<li>CDN引入依赖</li>
<li>第三方库按需引入</li>
<li>开启Gzip</li>
<li>关闭生产环境sourceMap<a id="more"></a>
</li>
</ul>
<h1 id="诊断与验证"><a href="#诊断与验证" class="headerlink" title="诊断与验证"></a>诊断与验证</h1><p>既然我们要做优化，我们必须先知道从哪些方面下手，最后如何去验证我们优化的效果。</p>
<ul>
<li>dist目录大小，最终打包的所有文件大小</li>
<li>webpack-bundle-analyzer，分析包中包含的模块的大小</li>
<li>浏览器调试工具，开启Disable Cache，查看客户端加载的资源大小以及速度</li>
</ul>
<p>主要介绍一下webpack-bundle-analyzer，看官方介绍：</p>
<blockquote>
<p>This module will help you:<br>&emsp;&emsp;1.Realize what’s really inside your bundle<br>&emsp;&emsp;2.Find out what modules make up the most of its size<br>&emsp;&emsp;3.Find modules that got there by mistake<br>&emsp;&emsp;4.Optimize it!</p>
</blockquote>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif" width="400px" style="margin: 0"></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>Vue CLI 3 默认支持打包报告，其实就是webpack-bundle-analyzer这个插件，使用<code>vue-cli-service build --report</code>就会在dist目录下生成一个report.html，打开这个页面就可以看到分析报告了。</p>
<p>为了方便使用，我们可以在package.json的scripts下面新增一行：<code>&quot;report&quot;: &quot;vue-cli-service build --report&quot;</code>，这样就可以使用<code>npm run report</code>命令实现了。</p>
<p>PS：老版本的vue cli可以通过<code>npm run build --report</code>命令，打包完成后会自动打开分析页面</p>
<p>怎么看这个报告呢？其实很简单，每一个分区代表打包以后的一个js文件，不同的颜色代表了文件的大小，从大到小，分区里面会嵌套分区，表示包对应的子模块；左侧的菜单展示了每个js文件在stat（原始）、parsed（编译后）、gizpped（压缩后）三种情况的大小。</p>
<h1 id="优化前后对比"><a href="#优化前后对比" class="headerlink" title="优化前后对比"></a>优化前后对比</h1><p>好不好，看疗效。我们先看结果再看过程。</p>
<h2 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h2><ul>
<li>dist目录大小为<code>13.3MB</code></li>
<li>打包后的本地js文件(/dist/static/js/)：<img src="https://i.loli.net/2019/02/21/5c6e6e6560c54.png" style="margin:0"></li>
<li>浏览器请求到的js文件：<img src="https://i.loli.net/2019/02/21/5c6e6e9632593.png" style="margin:0"></li>
<li>webpack-bundle-analyzer：<br><img src="https://i.loli.net/2019/02/21/5c6e6ec61afad.png" width="200px" style="display:inline-block"><img src="https://i.loli.net/2019/02/21/5c6e6eef659aa.png" width="200px" style="display:inline-block"><img src="https://i.loli.net/2019/02/21/5c6e6f1cd2b91.png" width="200px" style="display:inline-block"><br>可以看到，实际请求时需要加载两个本地js文件一共<code>1.95M</code>，还有一个第三方js文件<code>815kb</code>，合计<code>2.74M</code>，用时接近<code>10s</code>（吐槽下公司网络）。</li>
</ul>
<h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><ul>
<li>dist目录大小为<code>2.95MB</code></li>
<li>打包后的本地js文件(/dist/static/js/)：<img src="https://i.loli.net/2019/02/21/5c6e6f61d3795.png" style="margin:0"></li>
<li>浏览器请求到的js文件：<img src="https://i.loli.net/2019/02/21/5c6e6f8f55d8c.png" style="margin:0"></li>
<li>webpack-bundle-analyzer：<br><img src="https://i.loli.net/2019/02/21/5c6e6fafa0886.png" width="200px" style="display:inline-block"><img src="https://i.loli.net/2019/02/21/5c6e6fccf2b32.png" width="200px" style="display:inline-block"><img src="https://i.loli.net/2019/02/21/5c6e6fecd967b.png" width="200px" style="display:inline-block"><br>可以看到，实际请求时请求了4个本地js文件一共<code>156.5kb</code>，CDN加载了6个包，一共<code>207.5kb</code>，合计<code>364kb</code>，用时<code>2.2s</code>，注意，优化后是包含了CDN资源的大小，网上很多网上都没有计算CDN的资源。对比优化前体积减少了<code>87%</code>，加载时间减少了<code>78%</code>（受网路影响，不太精确）。显而易见，优化效果非常显著，基本实现了秒开页面，用户体验杠杠滴！</li>
</ul>
<h1 id="优化过程"><a href="#优化过程" class="headerlink" title="优化过程"></a>优化过程</h1><h2 id="Vue-Router-懒加载"><a href="#Vue-Router-懒加载" class="headerlink" title="Vue Router 懒加载"></a>Vue Router 懒加载</h2><p>首先看<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">官方文档</a>，是这样描述懒加载的</p>
<blockquote>
<p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>结合 Vue 的<a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">异步组件</a>和 Webpack 的<a href="https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/" target="_blank" rel="noopener">代码分割功能</a>，轻松实现路由组件的懒加载。</p>
</blockquote>
<p>实际操作非常简单，只需要把src/router.js中的组件引入方式从</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Page404 <span class="keyword">from</span> <span class="string">'./src/Page404.vue'</span>;</span><br></pre></td></tr></table></figure>
<p>变更为<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> page404 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/404.vue'</span>);</span><br></pre></td></tr></table></figure></p>
<p>就这样，over。当然，你想自定义分块也是可以的，通过 <a href="https://webpack.js.org/guides/code-splitting-require/#chunkname" target="_blank" rel="noopener">命名 chunk</a>可以将多个组件打包到一个异步块中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Foo.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Bar.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Baz.vue'</span>)</span><br></pre></td></tr></table></figure>
<p>最后的效果就是，打包后的js文件由之前的app.js和chunk-vendors.js多出了很多chunk，浏览器访问时会按需加载对应的chunk，从而减少了首屏的加载时间。</p>
<h2 id="CDN引入依赖"><a href="#CDN引入依赖" class="headerlink" title="CDN引入依赖"></a>CDN引入依赖</h2><p>CDN引入依赖很简单，使用script标签引入对应的资源即可，但是存在几个问题：</p>
<ol>
<li><p>CDN服务器挂了怎么办？</p>
<p>要是我们能检测到CDN是否成功就好了，当然能。常用的依赖包都会创建一个全局变量，通过检测这个环节变量就可以知道CDN的资源是否加载成功，不成功就加载服务器资源就可以了。缺点就是服务器上必须存放一份依赖包的备份，会增加包体积，但是并不影响访问速度。</p>
<p>怎么知道依赖包的全局变量呢？我们用axios举例，打开axios的Github的dist目录，可以看到axios.js和axios.min.js，我们要使用的是min包，但我们要在axios.js中去查找他的全局变量。其中有这样一段代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span>)</span><br><span class="line">		<span class="built_in">module</span>.exports = factory();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd)</span><br><span class="line">		define([], factory);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span>)</span><br><span class="line">		exports[<span class="string">"axios"</span>] = factory();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		root[<span class="string">"axios"</span>] = factory();</span><br></pre></td></tr></table></figure>
<p>我们就可以知道axios的全局变量就是axios了，在我们的publick/index.html中就可以这样检测</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入axios--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.18.0/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml">window.axios || document.write('<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&lt;%= BASE_URL %&gt;js/axios.min.js"</span>&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span>')</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就实现了高可用的CDN引入依赖了，不怕挂！</p>
</li>
<li><p>引入min包，没有了错误提醒，原有的业务代码中使用import引入的方式，CDN引入后无法使用了，维护两份代码？</p>
<p>为了减小包体积提升速度，CDN需要引入min包，但是就损失依赖自带的错误提醒，只适用于生产环境，传统的做法就是维护两分代码，开发版使用完整包 或者import引入，生产环境引入min包，这对于一个懒人来说太麻烦了。</p>
<p>要是能这样就好了，业务代码使用import方式引入依赖，开发环境加载完整包，生产环境使用CDN加载min包，完美！但是，这可能吗？当然可能，使用webpack的<a href="https://webpack.docschina.org/configuration/externals/" target="_blank" rel="noopener">externals</a>+<a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a>就可以轻松搞定啦！</p>
<p>externals的作用就是在使用CDN的情况下，业务代码中仍然可以使用import引入依赖。<a href="https://webpack.docschina.org/configuration/externals/" target="_blank" rel="noopener">官方文档</a>是这样说的</p>
<blockquote>
<p><strong>防止</strong>将某些 <code>import</code> 的包(package)<strong>打包</strong>到 bundle 中，而是在运行时(runtime)再去从外部获取这些<em>扩展依赖(external dependencies)</em>。</p>
</blockquote>
<p>externals在vue.config.js中的配置webpack</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">           config.externals = &#123;</span><br><span class="line">               <span class="string">'vue'</span>: <span class="string">'Vue'</span>,</span><br><span class="line">               <span class="string">'vuex'</span>: <span class="string">'Vuex'</span>,</span><br><span class="line">               <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">               <span class="string">'axios'</span>: <span class="string">'axios'</span>,</span><br><span class="line">               <span class="string">'vue-grid-layout'</span>: <span class="string">'VueGridLayout'</span></span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>配置的格式：<code>import包名: 全局变量</code>，工作原理就是webpack在读取到import语句时会从externals中去查找对应的全局变量然后加载。比如<code>&#39;vue-router&#39;: &#39;VueRouter&#39;</code>，业务代码中使用<code>import router from &#39;vue-router&#39;</code>，webpack就会去查找<code>VueRouter</code>这个全局变量。</p>
<p>通过<code>process.env.NODE_ENV === &#39;production&#39;</code>判断生产环境才配置externals，开发环境仍然加载<code>npm install</code>安装的依赖，这样就解决了生产环境使用import引入读取CDN资源的问题，但是开发环境CDN资源仍然会加载，我们并不会用到，这种浪费浏览器资源的事情是不能容忍的，必须干掉！这时候就需要html-webpack-plugin登场了。</p>
<p>html-webpack-plugin在Vue CLI 中主要负责处理public/index.html，具体查看<a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html" target="_blank" rel="noopener">文档</a>，在public/index.html中判断运行环境决定是否启用CDN。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (htmlWebpackPlugin.options.environment === <span class="string">'production'</span>) &#123; %&gt;</span><br><span class="line">&lt;!--引入axios--&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.18.0/dist/axios.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;window.axios || document.write('&lt;script src="&lt;%= BASE_URL %&gt;js/</span>axios.min.js<span class="string">"&gt;&lt;\/script&gt;')&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个<code>environment</code>并不是自带的，需要我们再vue.config.js中进行配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在htmlWebpackPlugin中增加环境变量，在index.html中使用</span></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config</span><br><span class="line">            .plugin(<span class="string">'html'</span>)</span><br><span class="line">            .tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">                args[<span class="number">0</span>].environment = process.env.NODE_ENV;</span><br><span class="line">                <span class="keyword">return</span> args;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，就实现高可用CDN的工程化了，不需要改业务代码，不需要开发环境生产环境两套代码，三分钟解决烦恼！</p>
</li>
</ol>
<h2 id="第三方库按需引入"><a href="#第三方库按需引入" class="headerlink" title="第三方库按需引入"></a>第三方库按需引入</h2><p>都有了CDN了，为什么还需要按需引入呢？举个例子，项目中需要使用lodash的deepClone和isEqual两个方法，使用前面的方法引入loadash，虽然有CDN的加持，但是我们仍然需要加载lodash的完整包，为了两个方法就要加载完整包还是有些得不偿失的，这种情况按需引入可以获得更快的加载速度。</p>
<p>具体按需引入的方法，<a href="https://www.echartsjs.com/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts" target="_blank" rel="noopener">echarts</a>、<a href="http://element-cn.eleme.io/#/zh-CN/component/quickstart" target="_blank" rel="noopener">element-ui</a>等官方文档都有说明，照着操作就可以了。</p>
<p>lodash的按需引入稍微麻烦一些，需要安装<code>babel-plugin-lodash</code>这个包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-lodash -D</span><br></pre></td></tr></table></figure>
<p>然后配置babel.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">        [<span class="string">'@babel/env'</span>, &#123; <span class="string">'targets'</span>: &#123; <span class="string">'node'</span>: <span class="number">6</span> &#125;&#125;]</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'plugins'</span>: [</span><br><span class="line">        <span class="string">'lodash'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _lodash = &#123;</span><br><span class="line">    cloneDeep: lodash.cloneDeep,</span><br><span class="line">    isEqual: lodash.isEqual</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>._ = _lodash;</span><br></pre></td></tr></table></figure>
<p>只有通过lodash的<code>.</code>运算符调用的方法才会被引入</p>
<h2 id="开启Gzip"><a href="#开启Gzip" class="headerlink" title="开启Gzip"></a>开启Gzip</h2><p>nginx的Gzip有两种方式，一种是服务器端的Gzip，这个大家都知道，就是每次请求时服务器先压缩再返回资源，对服务器性能有一定消耗；另一种是Gzip_static，就是打包时生成<code>.gz</code>文件，每次请求时服务器直接返回.gz文件，不消耗服务器性能。两种开启一种就可以了。</p>
<ol>
<li><p>服务器端Gzip</p>
<p>很简单，只需要配置一下nginx的配置就可以了</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启gzip</span></span><br><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU</span></span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span></span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">256</span>;</span><br><span class="line"><span class="comment"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到</span></span><br><span class="line"><span class="attribute">gzip_types</span> text/plain application/javascript application/x-javascript text/css application/xml text/javascript;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Gzip_static</p>
<p>需要安装<a href="https://github.com/webpack-contrib/compression-webpack-plugin" target="_blank" rel="noopener">compression-webpack-plugin</a>实现打包为.gz文件，然后开启nginx的gzip_static让nginx优先查找文件的.gz版本发送给客户端。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install compression-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>vue.config.js中配置webpack</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> productionGzipExtensions = [<span class="string">'js'</span>, <span class="string">'css'</span>]</span><br><span class="line">configureWebpack: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</span><br><span class="line">                asset: <span class="string">'[path].gz[query]'</span>,</span><br><span class="line">                algorithm: <span class="string">'gzip'</span>,</span><br><span class="line">                test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\.('</span> + productionGzipExtensions.join(<span class="string">'|'</span>) + <span class="string">')$'</span>),</span><br><span class="line">                threshold: <span class="number">10240</span>,</span><br><span class="line">                minRatio: <span class="number">0.8</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>nginx配置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启gzip_static</span></span><br><span class="line"><span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ol>
<li><p>配置vue.config.js关闭生成环境的sourcemap</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">productionSourceMap: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>减少不必要的第三方依赖</p>
</li>
<li><p>安装依赖区分开发模式，只在开发模式使用的依赖使用dev模式安装，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install xxx --save-dev</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>优化是没有极限的，不同的项目需要采用不同的优化方案，没有最好的，只有最合适的。填坑之路很漫长，但是我相信，办法总比困难多。</p>
]]></content>
      <categories>
        <category>optimize</category>
      </categories>
  </entry>
  <entry>
    <title>大文件上传解决方案</title>
    <url>/2018/09/19/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><h3 id="大数量文件上传"><a href="#大数量文件上传" class="headerlink" title="大数量文件上传"></a>大数量文件上传</h3><ul>
<li>支持文件信息列表展示</li>
<li>每个文件校验格式、大小等信息</li>
<li>每个文件计算上传百分比、速度、剩余时间</li>
</ul>
<h3 id="大容量文件上传"><a href="#大容量文件上传" class="headerlink" title="大容量文件上传"></a>大容量文件上传</h3><ul>
<li>支持断点续传</li>
<li>支持秒传</li>
<li>支持取消</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="上传文件夹"><a href="#上传文件夹" class="headerlink" title="上传文件夹"></a>上传文件夹</h3><p>大数量的文件上传都是通过上传文件夹的形式上传的，应该不会有人手动去选上万个文件的吧~<br>so，首先需要用webkitdirectory来启动选择文件夹</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">webkitdirectory</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="HTML5-File-API"><a href="#HTML5-File-API" class="headerlink" title="HTML5 File API"></a>HTML5 File API</h3><p>File API 提供了前端处理本地文件的能力，让图片预览、分块上传、拖拽上传等等神奇的操作变为可能。简单介绍一下我们会用到的部分，详细介绍看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" target="_blank" rel="noopener">官方文档</a></p>
<ul>
<li>FileList — input file标签获取到的值，是一个类数组，每个元素就是一个File对象。</li>
<li>File — FileList中的一个对象，包含文件的名称、大小、类别、修改时间等等基本信息。</li>
<li>FileReader — 文件读取的API，将文件读取到内存中，可以执行预览图片、计算MD5等等操作。</li>
<li>Blob — File对象就继承自Blob对象，二进制数据，提供操作接口，比如我们会用到的slice方法可以实现文件分块。</li>
</ul>
<h2 id="问题一：同时处理大量文件，浏览器直接崩溃？卡得要死？"><a href="#问题一：同时处理大量文件，浏览器直接崩溃？卡得要死？" class="headerlink" title="问题一：同时处理大量文件，浏览器直接崩溃？卡得要死？"></a>问题一：同时处理大量文件，浏览器直接崩溃？卡得要死？</h2><p>由于某些原因我们项目采用的单个文件依次上传的方式，上传部分就很简单了，只需要控制上传请求的数量就可以了，难点主要是对文件格式、大小的校验。</p>
<h3 id="获取到文件列表并逐一处理"><a href="#获取到文件列表并逐一处理" class="headerlink" title="获取到文件列表并逐一处理"></a>获取到文件列表并逐一处理</h3><p>如果我们直接用for循环取出每个文件进行处理，上万个文件同时加载可想而知，浏览器瞬间就投降了，这个时候就需要我们的Web Worker登场了，JavaScript主线程通过创建Worker线程，将一些计算密集型或高延迟型的任务交给Worker线程，充分发挥多核CPU的性能，避免主线程的阻塞和卡顿，下面简单介绍下如何使用，详细用法看<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">Web Worker 使用教程 — 阮一峰</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'work.js'</span>);</span><br><span class="line"><span class="comment">// 发送消息到work.js</span></span><br><span class="line">worker.postMessage(<span class="string">'Hello World'</span>);</span><br><span class="line"><span class="comment">// 接收work.js传出的消息</span></span><br><span class="line">worker.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Message：<span class="subst">$&#123;e.data&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 捕获work.js中抛出的错误</span></span><br><span class="line">worker.onerror = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Error：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从主线程关闭worker</span></span><br><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="comment">// 接收主线程传递的消息</span></span><br><span class="line">self.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Data：<span class="subst">$&#123;e.data&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 这是个例子，具体怎么处理自由发挥</span></span><br><span class="line">    <span class="keyword">switch</span> (e.data.cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'start'</span>:</span><br><span class="line">            <span class="comment">// 发送消息到主线程</span></span><br><span class="line">            self.postMessage(<span class="string">'worker start'</span>);</span><br><span class="line">            <span class="comment">// do something...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'stop'</span>:</span><br><span class="line">            self.postMessage(<span class="string">'worker stop'</span>);</span><br><span class="line">            <span class="comment">// 从子线程关闭worker</span></span><br><span class="line">            self.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            self.postMessage(<span class="string">'Unknown command:'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Web Worker可以理解为一个数据处理程序，传递一些消息或者数据给它，它会根据你设定的条件在需要的时候发送一个消息给你，你只需要监听对应的事件然后进行处理就好了。引入Web Worker后同时处理成千上万个文件的校验就不会引起浏览器的卡顿或者崩溃了，如果操作比较复杂，还可以多启动几个Worker来处理。、</p>
<h2 id="问题二：大文读取MD5导致浏览器崩溃？"><a href="#问题二：大文读取MD5导致浏览器崩溃？" class="headerlink" title="问题二：大文读取MD5导致浏览器崩溃？"></a>问题二：大文读取MD5导致浏览器崩溃？</h2><p>我们项目最早使用的是JavaScript MD5(<a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">github传送门</a>)，用于一些小文件的md5计算还可以，但是用于几百M的大文件就会出现浏览器卡顿、崩溃等问题，而且耗时较长。各种google之后发现了SparkMD5(<a href="https://github.com/satazor/js-spark-md5" target="_blank" rel="noopener">github传送门</a>)，SparkMD5是利用File API对文件进行分块之后进行的md5计算，效率很高，秒级运算而且不会引起浏览器的异常。示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验MD5</span></span><br><span class="line">        <span class="keyword">let</span> blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;</span><br><span class="line">        <span class="keyword">let</span> chunks = <span class="built_in">Math</span>.ceil(file.size / chunkSize);</span><br><span class="line">        <span class="keyword">let</span> currentChunk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> spark = <span class="keyword">new</span> SparkMD5();</span><br><span class="line">        <span class="keyword">let</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        <span class="keyword">const</span> loadNext = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> start = currentChunk * chunkSize;</span><br><span class="line">            <span class="keyword">let</span> end = ((start + chunkSize) &gt;= file.size) ? file.size : start + chunkSize;</span><br><span class="line">            fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// fileReader.readAsBinaryString(file);</span></span><br><span class="line">        fileReader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.log('read chunk nr', currentChunk + 1, 'of', chunks);</span></span><br><span class="line">            spark.append(e.target.result);</span><br><span class="line">            currentChunk++;</span><br><span class="line">            <span class="keyword">if</span> (currentChunk &lt; chunks) &#123;</span><br><span class="line">                loadNext();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// console.log('finished loading');</span></span><br><span class="line">                <span class="comment">// console.info('computed hash', spark.end());</span></span><br><span class="line">                <span class="comment">// spark.end()返回的就是文件的md5值了</span></span><br><span class="line">                <span class="comment">// 可以发送到服务器进行校验，从而实现秒传、续传等功能</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        fileReader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">'oops, something went wrong.'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        loadNext();</span><br></pre></td></tr></table></figure>
<h2 id="问题三：如何实现分块上传、续传、秒传？"><a href="#问题三：如何实现分块上传、续传、秒传？" class="headerlink" title="问题三：如何实现分块上传、续传、秒传？"></a>问题三：如何实现分块上传、续传、秒传？</h2><p>有了md5以后这几个需求就很好实现了，md5相同的文件就可以认为是同一个文件，每个文件上传之前先发送文件的md5到服务器进行校验，服务器返回这个文件还有哪些分块缺失，前端再发送需要的分块到服务器即可。当然，前后端必须要提前约定分块大小才能保证最后能在后端拼凑成一个完整的文件。</p>
<ul>
<li>服务器返回缺失部分分块就是续传了</li>
<li>服务器返回不缺失分块，就表示服务器上已经存在相同文件 ，前端显示秒传即可。</li>
</ul>
<p>分块上传示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chunkNum = <span class="number">0</span>; <span class="comment">// 分块编号</span></span><br><span class="line"><span class="keyword">let</span> chunkSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 分块大小10M</span></span><br><span class="line"><span class="keyword">let</span> chunks = <span class="built_in">Math</span>.ceil(file.size / chunkSize); <span class="comment">// 总分块数</span></span><br><span class="line"><span class="keyword">const</span> uploadChunk = <span class="function">(<span class="params">chunkNum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunkNum &lt; chunks) &#123;</span><br><span class="line">    	<span class="keyword">let</span> start = chunkNum * chunkSize;</span><br><span class="line">   		<span class="keyword">let</span> stop = <span class="built_in">Math</span>.min((start + chunkSize), file.size);</span><br><span class="line">    	<span class="keyword">let</span> fileTip = file.slice(start, stop);</span><br><span class="line">        upload(fileTip).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            chunkNum++;</span><br><span class="line">            uploadChunk(chunkNum);</span><br><span class="line">        &#125;).catch(&#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 上传完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">uploadChunk(chunkNum);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript错误捕获相关总结</title>
    <url>/2018/09/19/JavaScript%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="try-catch-？"><a href="#try-catch-？" class="headerlink" title="try-catch ？"></a>try-catch ？</h1><p><strong>try-catch的好处：</strong><span data-type="color" style="color:rgb(26, 26, 26)"><span data-type="background" style="background-color:rgb(255, 255, 255)"><strong>增强代码的健壮性而不必影响程序的主逻辑，保持代码的简洁清晰</strong></span></span><br><a id="more"></a></p>
<blockquote>
<p>通常情况下，<strong>使用者（包括用户、代码库的使用者）所引发的错误，需要通过异常机制来处理</strong>。<br>因为异常发生的时候，原订的执行流程就无法继续，但对于用户来讲，他们不能因为这样的错误就终止程序的使用，所以提供给程序设计者异常机制，让设计者决定发生意外的时候应该做些什么。而这种意外的产生原因是用户，用户的操作千千万万，导致的结果也可能千奇百怪，但是他们的操作若使得原有流程无法继续，那么就是异常。</p>
<p>楼主说的判断文件先存在，再读写文件，其实就是这个问题，按照程序的流程，可以保证在判断是否存在的时候，文件的存在性，但是不能保证在真正操作文件的时候文件的存在性（例如判断的时候文件还在，真正操作之前却被用户自己删掉了）。因为流程上无法对流程外的用户行为（用户删文件）作出保证，所以需要异常机制。</p>
<p><strong>我认为，用户在程序运行时触发所导致的错误，需要异常机制来捕捉和处理。</strong></p>
<p>作者：Blueve<br>链接：<a href="https://www.zhihu.com/question/27122172/answer/35335950" target="_blank" rel="noopener">https://www.zhihu.com/question/27122172/answer/35335950</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="try-catch用来处理可预知的异常"><a href="#try-catch用来处理可预知的异常" class="headerlink" title="try-catch用来处理可预知的异常"></a>try-catch用来<span data-type="color" style="color:rgb(26, 26, 26)"><span data-type="background" style="background-color:rgb(255, 255, 255)">处理可预知的异常</span></span></h3><h4 id="可预知"><a href="#可预知" class="headerlink" title="可预知"></a>可预知</h4><p>try-catch仅能用来处理可预知的错误，如：</p>
<blockquote>
<p>楼主说的判断文件先存在，再读写文件，其实就是这个问题，按照程序的流程，可以保证在判断是否存在的时候，文件的存在性，但是不能保证在真正操作文件的时候文件的存在性（例如判断的时候文件还在，真正操作之前却被用户自己删掉了）。因为流程上无法对流程外的用户行为（用户删文件）作出保证，所以需要异常机制。<br>如果catch到不可预知的错误，就无法合理处理错误，这时就需要throw到上一层，由上层统一处理。</p>
</blockquote>
<h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><p>try-catch后必须要处理错误，如果该错误无法处理，请不要使用try-catch，直接将error暴露给上层，由上层统一处理。不然会导致无法正常定位错误。<br>反例：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doAnything();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// did nothing;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="promise-catch"><a href="#promise-catch" class="headerlink" title="promise.catch ?"></a>promise.catch ?</h1><p>在一个promise链中，只要任何一个promise被reject，promise链就被破坏了，reject之后的promise都不会再执行，而是直接调用.catch方法。正确使用.catch有利于定位错误在promise链中的位置。<br>处理示例：<br>直接处理错误或将错误重新抛出为更高等级的错误<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">.then(<span class="function">(<span class="params">output</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> doAsyncOperation3();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Re-throw the error as a higher-level error.</span></span><br><span class="line">  <span class="comment">// We will include the message from the lower-level </span></span><br><span class="line">  <span class="comment">// error as part of the error message for this error.</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Higher-level error. '</span> + err.message);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// In here we will get the higher-level error.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="throw-error-？"><a href="#throw-error-？" class="headerlink" title="throw error ？"></a>throw error ？</h1><p>从技术上将，我们可以throw任何类型值。但应尽量与内置对象达到兼容（throw有 <code>name</code> 和 <code>message</code> 属性的对象）。<br>JavaScript 内置了许多标准错误对象类型：<code>Error</code>、<code>SyntaxError</code>、<code>ReferenceError</code>、<code>TypeError</code> 等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(message);</span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(message);</span><br></pre></td></tr></table></figure>
<p>对于内置的错误对象，<code>name</code> 属性正是对应构造函数名（如：Error,syntaxError,ReferenceError），<code>message</code> 属性值为传入的参数值。<br>用例：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getAppname() &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.pkg.name) &#123;</span><br><span class="line">     debug(<span class="string">'Loaded appname(%s) from package.json'</span>, <span class="keyword">this</span>.pkg.name);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.pkg.name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> pkg = path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'package.json'</span>);</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`name is required from <span class="subst">$&#123;pkg&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="assert"><a href="#assert" class="headerlink" title="assert ?"></a>assert ?</h1><blockquote>
<p>程序设计中还有一种叫<strong>断言</strong>（ASSERT）的东西，这种机制是用来约束程序设计者的，例如某些库的某些函数，在文档中约定了，这个函数的参数必须是&gt;0，那么你在编程的时候愣是硬生生输入一个0，那么这时候就应该选择断言，用于帮助程序设计者及早的发现自己程序中的错误（这种错误是设计上的错误所引发的，而非用户的操作所导致的），而不是用异常机制去处理。<br><strong>所以，由程序员设计不足所导致的错误，需要用断言来捕捉和处理。</strong></p>
<p>作者：Blueve<br>链接：<a href="https://www.zhihu.com/question/27122172/answer/35335950" target="_blank" rel="noopener">https://www.zhihu.com/question/27122172/answer/35335950</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> <span class="keyword">extends</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">options</span></span> - options same as &#123;<span class="doctag">@link </span>FileLoader&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>options.fieldClass - determine the field name of inject object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    assert(options.property, <span class="string">'options.property is required'</span>);</span><br><span class="line">    assert(options.inject, <span class="string">'options.inject is required'</span>);</span><br><span class="line">    <span class="keyword">const</span> target = options.target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (options.fieldClass) &#123;</span><br><span class="line">      options.inject[options.fieldClass] = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>(options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">this</span>.options.inject;</span><br><span class="line">    <span class="keyword">const</span> property = options.property;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define ctx.service</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(app.context, property, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// distinguish property cache,</span></span><br><span class="line">        <span class="comment">// cache's lifecycle is the same with this context instance</span></span><br><span class="line">        <span class="comment">// e.x. ctx.service1 and ctx.service2 have different cache</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>[CLASSLOADER]) &#123;</span><br><span class="line">          <span class="keyword">this</span>[CLASSLOADER] = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> classLoader = <span class="keyword">this</span>[CLASSLOADER];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> instance = classLoader.get(property);</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">          instance = getInstance(target, <span class="keyword">this</span>);</span><br><span class="line">          classLoader.set(property, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CodeReview</category>
      </categories>
      <tags>
        <tag>CodeReview</tag>
        <tag>try-catch</tag>
        <tag>throw</tag>
        <tag>promise.catch</tag>
      </tags>
  </entry>
  <entry>
    <title>博客自动部署</title>
    <url>/2018/09/13/%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>利用github的webHooks实现hexo项目的自动打包部署</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>node.js，Git</li>
<li>github/码云上创建hexo项目</li>
<li>一台云服务器/本地服务器，需要公网IP</li>
<li>一点后端代码和shell脚本</li>
</ul>
<a id="more"></a>
<h3 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h3><p>在服务器的项目目录下执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ git <span class="built_in">clone</span> 你的hexo项目git地址</span><br><span class="line">$ <span class="built_in">cd</span> 你的项目名称</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<h3 id="设置webHooks钩子"><a href="#设置webHooks钩子" class="headerlink" title="设置webHooks钩子"></a>设置webHooks钩子</h3><p>1、 登录github/码云，进入项目-管理-webHooks<br>2、 添加/新增钩子，每次向这个项目push代码，就会触发这个钩子，像服务器发送一个请求，URL/POST地址设置为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://139.196.161.11:8080/hooks?password=yourpassword&amp;filename=你的shell脚本名称</span><br></pre></td></tr></table></figure></p>
<p>3、 服务器端接受到请求传过来的filename参数，执行对应的shell脚本<br>shell脚本主要代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /xxx/你的项目名称</span><br><span class="line">git pull</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title>markdown语法介绍</title>
    <url>/2018/09/13/markdown/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Author</th>
<th>果冻虾仁</th>
</tr>
</thead>
<tbody>
<tr>
<td>E-mail</td>
<td><a href="mailto:Jelly.K.Wang@qq.com" target="_blank" rel="noopener">Jelly.K.Wang@qq.com</a></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#横线">横线</a></li>
<li><a href="#标题">标题</a></li>
<li><a href="#文本">文本</a><ul>
<li>普通文本</li>
<li>单行文本</li>
<li>多行文本</li>
<li>文字高亮</li>
<li>换行</li>
<li>斜体</li>
<li>粗体</li>
<li>删除线</li>
</ul>
</li>
<li><a href="#图片">图片</a><ul>
<li>来源于网络的图片</li>
<li>GitHub仓库中的图片</li>
</ul>
</li>
<li><a href="#链接">链接</a><ul>
<li>文字超链接<ul>
<li>链接外部URL</li>
<li>链接本仓库里的URL</li>
</ul>
</li>
<li>锚点</li>
<li><a href="#图片链接">图片链接</a></li>
</ul>
</li>
<li><a href="#列表">列表</a><ul>
<li>无序列表</li>
<li>有序列表</li>
<li>复选框列表</li>
</ul>
</li>
<li><a href="#块引用">块引用</a></li>
<li><a href="#代码高亮">代码高亮</a></li>
<li><a href="#表格">表格</a></li>
<li><a href="#表情">表情</a></li>
<li><a href="#diff语法">diff语法</a></li>
</ul>
<h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><hr>
<p>***、—、___可以显示横线效果</p>
<hr>
<hr>
<hr>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><h3 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h3><p>这是一段普通的文本</p>
<h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><pre><code>Hello,大家好，我是果冻虾仁。
</code></pre><p>在一行开头加入1个Tab或者4个空格。</p>
<h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><h4 id="语法1"><a href="#语法1" class="headerlink" title="语法1"></a>语法1</h4><p>在连续几行的文本开头加入1个Tab或者4个空格。</p>
<pre><code>欢迎到访
很高兴见到您
祝您，早上好，中午好，下午好，晚安
</code></pre><h4 id="语法2"><a href="#语法2" class="headerlink" title="语法2"></a>语法2</h4><p>使用一对各三个的反引号：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">欢迎到访</span><br><span class="line">我是C++码农</span><br><span class="line">你可以在知乎、CSDN、简书搜索【果冻虾仁】找到我</span><br></pre></td></tr></table></figure></p>
<p>该语法也可以实现代码高亮，见<a href="#代码高亮">代码高亮</a></p>
<h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><p>文字高亮功能能使行内部分文字高亮，使用一对反引号。<br>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`linux` `网络编程` `socket` `epoll`</span><br></pre></td></tr></table></figure></p>
<p>效果：<code>linux</code> <code>网络编程</code> <code>socket</code> <code>epoll</code></p>
<p>也适合做一篇文章的tag</p>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>直接回车不能换行，<br>可以在上一行文本后面补两个空格，<br>这样下一行的文本就换行了。</p>
<p>或者就是在两行文本直接加一个空行。</p>
<p>也能实现换行效果，不过这个行间距有点大。</p>
<h4 id="斜体、粗体、删除线"><a href="#斜体、粗体、删除线" class="headerlink" title="斜体、粗体、删除线"></a>斜体、粗体、删除线</h4><table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*斜体1*</code></td>
<td><em>斜体1</em></td>
</tr>
<tr>
<td><code>_斜体2_</code></td>
<td><em>斜体2</em></td>
</tr>
<tr>
<td><code>**粗体1**</code></td>
<td><strong>粗体1</strong></td>
</tr>
<tr>
<td><code>__粗体2__</code></td>
<td><strong>粗体2</strong></td>
</tr>
<tr>
<td><code>这是一个 ~~删除线~~</code></td>
<td>这是一个 <del>删除线</del></td>
</tr>
<tr>
<td><code>***斜粗体1***</code></td>
<td><strong><em>斜粗体1</em></strong></td>
</tr>
<tr>
<td><code>___斜粗体2___</code></td>
<td><strong><em>斜粗体2</em></strong></td>
</tr>
<tr>
<td><code>***~~斜粗体删除线1~~***</code></td>
<td><strong><em><del>斜粗体删除线1</del></em></strong></td>
</tr>
<tr>
<td><code>~~***斜粗体删除线2***~~</code></td>
<td><del><strong><em>斜粗体删除线2</em></strong></del></td>
</tr>
</tbody>
</table>
<pre><code>斜体、粗体、删除线可混合使用
</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>基本格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![alt](URL title)</span><br></pre></td></tr></table></figure></p>
<p>alt和title即对应HTML中的alt和title属性（都可省略）：</p>
<ul>
<li>alt表示图片显示失败时的替换文本</li>
<li>title表示鼠标悬停在图片时的显示文本（注意这里要加引号）</li>
</ul>
<p>URL即图片的url地址，如果引用本仓库中的图片，直接使用<strong>相对路径</strong>就可了，如果引用其他github仓库中的图片要注意格式，即：<code>仓库地址/raw/分支名/图片路径</code>，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>#</th>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>![baidu](http://www.baidu.com/img/bdlogo.gif &quot;百度logo&quot;)</code></td>
<td><img src="http://www.baidu.com/img/bdlogo.gif" alt="baidu" title="百度logo"></td>
</tr>
<tr>
<td>2</td>
<td><code>![][foryou]</code></td>
<td><img src="https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif" alt></td>
</tr>
</tbody>
</table>
<p>注意例2的写法使用了<strong>URL标识符</strong>的形式，在<a href="#链接">链接</a>一节有介绍。</p>
<blockquote>
<p>在文末有foryou的定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[foryou]:https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="链接外部URL"><a href="#链接外部URL" class="headerlink" title="链接外部URL"></a>链接外部URL</h3><table>
<thead>
<tr>
<th>#</th>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>[我的博客](http://blog.csdn.net/guodongxiaren &quot;悬停显示&quot;)</code></td>
<td><a href="http://blog.csdn.net/guodongxiaren" title="悬停显示" target="_blank" rel="noopener">我的博客</a></td>
</tr>
<tr>
<td>2</td>
<td><code>[我的知乎][zhihu]</code></td>
<td><a href="https://www.zhihu.com/people/jellywong" title="我的知乎，欢迎关注" target="_blank" rel="noopener">我的知乎</a></td>
</tr>
</tbody>
</table>
<p>语法2由两部分组成：</p>
<ul>
<li>第一部分使用两个中括号，[ ]里的标识符（本例中zhihu），可以是数字，字母等的组合，标识符上下对应就行了（<strong>姑且称之为URL标识符</strong>）</li>
<li>第二部分标记实际URL。</li>
</ul>
<blockquote>
<p>使用URL标识符能达到复用的目的，一般把全文所有的URL标识符统一放在文章末尾，这样看起来比较干净。</p>
<blockquote>
<p>URL标识符是我起的名字，不知道是否准确。囧。。</p>
</blockquote>
</blockquote>
<h3 id="链接本仓库里的URL"><a href="#链接本仓库里的URL" class="headerlink" title="链接本仓库里的URL"></a>链接本仓库里的URL</h3><table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[我的简介](/example/profile.md)</code></td>
<td><a href="/example/profile.md">我的简介</a></td>
</tr>
<tr>
<td><code>[example](./example)</code></td>
<td><a href="./example">example</a></td>
</tr>
</tbody>
</table>
<h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><p>给图片加链接的本质是混合图片显示语法和普通的链接语法。普通的链接中[ ]内部是链接要显示的文本，而图片链接[ ]里面则是要显示的图片。<br>直接混合两种语法当然可以，但是十分啰嗦，为此我们可以使用URL标识符的形式。</p>
<table>
<thead>
<tr>
<th>#</th>
<th>语法</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>[![weibo-logo]](http://weibo.com/linpiaochen)</code></td>
<td style="text-align:center"><a href="http://weibo.com/linpiaochen" target="_blank" rel="noopener"><img src="/img/weibo.png" alt="weibo-logo" title="点击图片进入我的微博"></a></td>
</tr>
<tr>
<td>2</td>
<td><code>[![](/img/zhihu.png &quot;我的知乎，欢迎关注&quot;)][zhihu]</code></td>
<td style="text-align:center"><a href="https://www.zhihu.com/people/jellywong" title="我的知乎，欢迎关注" target="_blank" rel="noopener"><img src="/img/zhihu.png" alt title="我的知乎，欢迎关注"></a></td>
</tr>
<tr>
<td>3</td>
<td><code>[![csdn-logo]][csdn]</code></td>
<td style="text-align:center"><a href="http://blog.csdn.net/guodongxiaren" title="我的博客" target="_blank" rel="noopener"><img src="/img/csdn.png" alt="csdn-logo" title="我的CSDN博客"></a></td>
</tr>
</tbody>
</table>
<p>因为图片本身和链接本身都支持URL标识符的形式，所以图片链接也可以很简洁（见例3）。<br>注意，此时鼠标悬停时显示的文字是图片的title，而非链接本身的title了。</p>
<blockquote>
<p>本文URL标识符都放置于文末</p>
</blockquote>
<h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>其实呢，每一个标题都是一个锚点，和HTML的锚点（<code>#</code>）类似，比如我们</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[回到顶部](#readme)</code></td>
<td><a href="#readme">回到顶部</a></td>
</tr>
</tbody>
</table>
<p>不过要注意，标题中的英文字母都被转化为<strong>小写字母</strong>了。</p>
<blockquote>
<p>以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！</p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li>昵称：果冻虾仁</li>
</ul>
<ul>
<li>别名：隔壁老王</li>
</ul>
<ul>
<li>英文名：Jelly</li>
</ul>
<h3 id="多级无序列表"><a href="#多级无序列表" class="headerlink" title="多级无序列表"></a>多级无序列表</h3><ul>
<li>编程语言<ul>
<li>脚本语言<ul>
<li>Python</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><h4 id="一般效果"><a href="#一般效果" class="headerlink" title="一般效果"></a>一般效果</h4><p>就是在数字后面加一个点，再加一个空格。不过看起来起来可能不够明显。<br>面向对象的三个基本特征：</p>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<h4 id="多级有序列表"><a href="#多级有序列表" class="headerlink" title="多级有序列表"></a>多级有序列表</h4><p>和无序列表一样，有序列表也有多级结构：</p>
<ol>
<li>这是一级的有序列表，数字1还是1<ol>
<li>这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字<ol>
<li>这是三级的有序列表，数字在显示的时候变成了英文字母</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="复选框列表"><a href="#复选框列表" class="headerlink" title="复选框列表"></a>复选框列表</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> 需求分析</li>
<li style="list-style: none"><input type="checkbox" checked> 系统设计</li>
<li style="list-style: none"><input type="checkbox" checked> 详细设计</li>
<li style="list-style: none"><input type="checkbox"> 编码</li>
<li style="list-style: none"><input type="checkbox"> 测试</li>
<li style="list-style: none"><input type="checkbox"> 交付</li>
</ul>
<p>您可以使用这个功能来标注某个项目各项任务的完成情况。</p>
<blockquote>
<p>Tip:</p>
<blockquote>
<p>在GitHub的<strong>issue</strong>中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。</p>
</blockquote>
</blockquote>
<h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><h3 id="常用于引用文本"><a href="#常用于引用文本" class="headerlink" title="常用于引用文本"></a>常用于引用文本</h3><h4 id="文本摘自《深入理解计算机系统》P27"><a href="#文本摘自《深入理解计算机系统》P27" class="headerlink" title="文本摘自《深入理解计算机系统》P27"></a>文本摘自《深入理解计算机系统》P27</h4><p>　令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。</p>
<blockquote>
<p><strong>“端”（endian）的起源</strong><br>以下是Jonathan Swift在1726年关于大小端之争历史的描述：<br>“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。”</p>
</blockquote>
<h3 id="块引用有多级结构"><a href="#块引用有多级结构" class="headerlink" title="块引用有多级结构"></a>块引用有多级结构</h3><blockquote>
<p>数据结构</p>
<blockquote>
<p>树</p>
<blockquote>
<p>二叉树</p>
<blockquote>
<p>平衡二叉树</p>
<blockquote>
<p>满二叉树</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;&#125; <span class="comment">//Java</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">//C</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello GitHub"</span> <span class="comment">#Bash</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myH1"</span>).innerHTML=<span class="string">"Welcome to my Homepage"</span>; <span class="comment">//javascipt</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp;<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">string</span>&amp; A,<span class="keyword">const</span> <span class="built_in">string</span>&amp; B) <span class="comment">//cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
</tr>
</thead>
<tbody>
<tr>
<td>表格单元</td>
<td>表格单元</td>
<td></td>
</tr>
<tr>
<td>表格单元</td>
<td>表格单元</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
</tr>
</thead>
<tbody>
<tr>
<td>表格单元</td>
<td>表格单元</td>
</tr>
<tr>
<td>表格单元</td>
<td>表格单元</td>
</tr>
</tbody>
</table>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>表格可以指定对齐方式</p>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐</th>
<th style="text-align:center">居中</th>
<th style="text-align:right">右对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">col 3 is</td>
<td style="text-align:center">some wordy text</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td style="text-align:left">col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td style="text-align:left">zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h3 id="混合其他语法"><a href="#混合其他语法" class="headerlink" title="混合其他语法"></a>混合其他语法</h3><p>表格单元中的内容可以和其他大多数GFM语法配合使用，如：</p>
<h4 id="使用普通文本的删除线，斜体等效果"><a href="#使用普通文本的删除线，斜体等效果" class="headerlink" title="使用普通文本的删除线，斜体等效果"></a>使用普通文本的删除线，斜体等效果</h4><table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Help</td>
<td><del>Display the</del> help window.</td>
</tr>
<tr>
<td>Close</td>
<td><em>Closes</em> a window</td>
</tr>
</tbody>
</table>
<h4 id="表格中嵌入图片（链接）"><a href="#表格中嵌入图片（链接）" class="headerlink" title="表格中嵌入图片（链接）"></a>表格中嵌入图片（链接）</h4><p>其实前面介绍图片显示、图片链接的时候为了清晰就是放在在表格中显示的。</p>
<table>
<thead>
<tr>
<th>图片</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="http://www.baidu.com/img/bdlogo.gif" alt="baidu" title="百度logo"></td>
<td>百度</td>
</tr>
</tbody>
</table>
<h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p>
<p>比如<code>:blush:</code>，可以显示:blush:。</p>
<p>具体每一个表情的符号码，可以查询GitHub的官方网页<a href="http://www.emoji-cheat-sheet.com" target="_blank" rel="noopener">http://www.emoji-cheat-sheet.com</a>。</p>
<p>但是这个网页每次都打开<strong>奇慢</strong>。。所以我整理到了本repo中，大家可以直接在此查看<a href="./emoji.md">emoji</a>。</p>
<h2 id="diff语法"><a href="#diff语法" class="headerlink" title="diff语法"></a>diff语法</h2><p>版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。<br>GFM中可以显示的展示diff效果。使用绿色表示新增，红色表示删除。</p>
<p>其语法与代码高亮类似，只是在三个反引号后面写diff，<br>并且其内容中，以 <code>+</code>开头表示新增，<code>-</code>开头表示删除。</p>
<p>效果如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 鸟宿池边树，僧敲月下门</span></span><br><span class="line"><span class="deletion">- 鸟宿池边树，僧推月下门</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeReview问题与总结第一期</title>
    <url>/2018/09/11/CodeReview%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="常用的遍历方法有哪些？每种适用于什么场景，各有什么优缺点？"><a href="#常用的遍历方法有哪些？每种适用于什么场景，各有什么优缺点？" class="headerlink" title="常用的遍历方法有哪些？每种适用于什么场景，各有什么优缺点？"></a>常用的遍历方法有哪些？每种适用于什么场景，各有什么优缺点？</h2><a id="more"></a>
<h3 id="常用遍历方法"><a href="#常用遍历方法" class="headerlink" title="常用遍历方法"></a>常用遍历方法</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p><strong>语法：</strong></p>
<blockquote>
<p>for (语句 1; 语句 2; 语句 3)   {   被执行的代码块   }<br>语句 1 在循环（代码块）开始前执行<br>语句 2 定义运行循环（代码块）的条件<br>语句 3 在循环（代码块）已被执行之后执行  </p>
</blockquote>
<h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p><code>for...in</code>语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。</p>
<p><strong>语法：</strong> </p>
<blockquote>
<p>for (variable in object) {…}<br>  variable：在每次迭代时，将不同的属性名分配给变量。<br>  object：被迭代枚举其属性的对象。</p>
</blockquote>
<p><strong>注意：<code>for...in</code>不应该用于迭代一个 Array</strong></p>
<ul>
<li><code>for...in</code>不仅可以遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。（即：<code>for...in</code>循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。）</li>
<li>不能保证<code>for...in</code>将以任何特定的顺序返回索引。</li>
</ul>
<p><strong>应用：</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"obj."</span> + prop + <span class="string">" = "</span> + obj[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><p><code>for...of</code>语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<p><strong>语法：</strong></p>
<blockquote>
<p>for (variable of iterable) {<br>      //statements<br>  }<br>  variable：在每次迭代中，将不同属性的值分配给变量。<br>  iterable：可枚举其枚举属性的对象。</p>
</blockquote>
<p><strong>注意：可以使用<code>break</code>跳出循环</strong><br><strong>应用：</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> iterable)&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; <span class="number">20</span>) &#123;</span><br><span class="line">   	<span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">   	<span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p><code>forEach</code>方法对数组的每个元素执行一次提供的函数。<br><strong>语法：</strong></p>
<blockquote>
<p>array.forEach(callback(currentValue, index, array){<br> //do something<br> }, this)<br> array.forEach(callback[, thisArg])  </p>
</blockquote>
<p><strong>参数：</strong> </p>
<blockquote>
<p>currentValue(当前值)：数组中正在处理的当前元素。<br> index(索引)：数组中正在处理的当前元素的索引。<br> array：forEach()方法正在操作的数组。<br> thisArg：可选参数。当执行回调 函数时用作this的值(参考对象)。</p>
</blockquote>
<p><strong>应用：</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function"><span class="params">element</span> =&gt;</span> <span class="built_in">console</span>.log(element));</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复制对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">  <span class="keyword">var</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">  propNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, name);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(copy, name, desc);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = copy(obj1);</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong><br>不能中途跳出循环，如果数组在迭代时被修改了，则其他元素会被跳过。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>];</span><br><span class="line">words.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(word);</span><br><span class="line">  <span class="keyword">if</span> (word === <span class="string">"two"</span>) &#123;</span><br><span class="line">    words.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// four</span></span><br></pre></td></tr></table></figure></p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><code>map</code>方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br><strong>语法：</strong></p>
<blockquote>
<p>arr.map(function callback(currentValue, index, array) {<br>     // Return element for new_array<br>  }[, thisArg])</p>
</blockquote>
<p><strong>参数：</strong></p>
<blockquote>
<p>callback： 生成新数组元素的函数，使用三个参数：<br>currentValue callback： 的第一个参数，数组中正在处理的当前元素。<br>index callback： 的第二个参数，数组中正在处理的当前元素的索引。<br>array callback： 的第三个参数，map方法被调用的数组。<br>thisArg： 可选的。执行 callback 函数时 使用的this 值。</p>
</blockquote>
<p><strong>返回值：</strong><br>一个新数组，每个元素都是回调函数的结果。</p>
<p><strong>应用：</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重新格式化数组</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> roots = numbers.map(<span class="built_in">Math</span>.sqrt);</span><br><span class="line"><span class="comment">// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>缺点：</strong> 不能中途跳出循环。</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>测试环境：node v9.8.0<br>测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">测试环境：node v9<span class="number">.8</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">JavaScript</span><br><span class="line"><span class="keyword">var</span> number = <span class="number">100</span>; <span class="comment">// array大小</span></span><br><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">    array[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> len = array.length;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'数组长度为：'</span>, number)</span><br><span class="line"><span class="comment">// 正常for循环</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'normal for'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    array[i] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'normal for'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒序for循环</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'reverse for'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i--;) &#123;</span><br><span class="line">    array[i] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'reverse for'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'while'</span>);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">    array[i] + <span class="number">1</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'while'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-in循环</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'for-in'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> array) &#123;</span><br><span class="line">    array[i] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'for-in'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for each 循环</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"for each"</span>);</span><br><span class="line">array.forEach(<span class="function"><span class="params">e</span> =&gt;</span> e + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"for each"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map循环</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"map"</span>);</span><br><span class="line">array.map(<span class="function"><span class="params">e</span> =&gt;</span> e + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"map"</span>)</span><br></pre></td></tr></table></figure>
<p>测试结果(ms为单位)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数组长度</th>
<th style="text-align:center">100</th>
<th style="text-align:center">1000</th>
<th style="text-align:center">10000</th>
<th style="text-align:center">100000</th>
<th style="text-align:center">1000000</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">普通for循环</td>
<td style="text-align:center">0.101</td>
<td style="text-align:center">0.125</td>
<td style="text-align:center">0.343</td>
<td style="text-align:center">0.224</td>
<td style="text-align:center">4.778</td>
</tr>
<tr>
<td style="text-align:center">倒序for循环</td>
<td style="text-align:center">0.009</td>
<td style="text-align:center">0.030</td>
<td style="text-align:center">0.255</td>
<td style="text-align:center">8.606</td>
<td style="text-align:center">4.391</td>
</tr>
<tr>
<td style="text-align:center">while循环</td>
<td style="text-align:center">0.007</td>
<td style="text-align:center">0.028</td>
<td style="text-align:center">0.24</td>
<td style="text-align:center">23.957</td>
<td style="text-align:center">4.445</td>
</tr>
<tr>
<td style="text-align:center">for-in</td>
<td style="text-align:center">0.032</td>
<td style="text-align:center">0.351</td>
<td style="text-align:center">2.466</td>
<td style="text-align:center">22.203</td>
<td style="text-align:center">163.261</td>
</tr>
<tr>
<td style="text-align:center">for-each</td>
<td style="text-align:center">0.030</td>
<td style="text-align:center">0.054</td>
<td style="text-align:center">0.296</td>
<td style="text-align:center">1.986</td>
<td style="text-align:center">14.921</td>
</tr>
<tr>
<td style="text-align:center">map</td>
<td style="text-align:center">0.029</td>
<td style="text-align:center">0.055</td>
<td style="text-align:center">0.323</td>
<td style="text-align:center">19.905</td>
<td style="text-align:center">189.387</td>
</tr>
</tbody>
</table>
<p><strong>思考：我们选择循环的多个角度——业务需要、代码可读性、性能。</strong><br><strong>小结：</strong> 多数情况下前端不会涉及到大数量级的运算，如果有，那么应该考虑业务代码的正确性或者是否该将运算交到后端处理，在小数据量的运算中优先考虑代码的可读性、可维护性：采用<code>for-each</code>和<code>map</code>方法。</p>
<p><strong>延伸阅读：</strong> 为什么for-in效率相比而言这么低？<br><code>for...in</code> 一般是用在对象属性名的遍历上的，由于每次迭代操作会同时搜索实例本身的属性以及原型链上的属性，所以效率肯定低下。for-in实际上效率是最低的。这是因为 <code>for...in</code>有一些特殊的要求，具体包括：</p>
<ol>
<li>遍历所有属性，不仅是 <code>ownproperties</code> 也包括原型链上的所有属性。</li>
<li>忽略 <code>enumerable</code>(可枚举) 为 <code>false</code> 的属性。</li>
<li>必须按特定顺序遍历，先遍历所有数字键，然后按照创建属性的顺序遍历剩下的。</li>
</ol>
<p>相关链接：<br><a href="https://github.com/jawil/blog/issues/2" target="_blank" rel="noopener">吹毛求疵的追求优雅高性能JavaScript</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">Array-MDN</a></p>
<h2 id="Vue是如何实现响应式的？监测变化时应注意什么？"><a href="#Vue是如何实现响应式的？监测变化时应注意什么？" class="headerlink" title="Vue是如何实现响应式的？监测变化时应注意什么？"></a>Vue是如何实现响应式的？监测变化时应注意什么？</h2><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为 getter/setter。<code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。<br>每个组件实例都有相应的 <code>watcher</code> 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 <code>setter</code> 被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新。</p>
<p><img src="https://ww2.sinaimg.cn/large/005YhI8igy1fv5p3zefoej30xc0kuq38" alt="vue"></p>
<p>监测变化时应注意：</p>
<ol>
<li><p>Vue 不能检测到对象属性的添加或删除。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能检测以下变动的数组:</p>
</li>
</ol>
<ul>
<li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ul>
<p>相关链接：<br><a href="https://012-cn.vuejs.org/guide/best-practices.html" target="_blank" rel="noopener">Vue细节与最佳实践</a><br><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">Vue对象更改检测注意事项</a></p>
]]></content>
      <categories>
        <category>CodeReview</category>
      </categories>
      <tags>
        <tag>CodeReview</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>博客使用说明</title>
    <url>/2018/09/11/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="./2018/09/10/markdown/">GFM（GitHub Flavored Markdown）</a>解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<a id="more"></a>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://gitee.com/cisdi/hexo.git</span><br></pre></td></tr></table></figure>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><p>使用以下命令，或者在/source/_posts/目录下新建markdown文件<br>参考：<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">Hexo文档</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></p>
<p>文章头部添加以下代码，配置文章选项(Front-matter)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: //标题</span><br><span class="line">date: //创建日期</span><br><span class="line">tags: [标签一,标签二]</span><br><span class="line">categories: //分类</span><br><span class="line">hidden：true/false //是否隐藏</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>在首页隐藏文章的大部分内容，加入以下代码，后面的代码将会在首页隐藏<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure></p>
<p>运行服务，本地实时预览效果<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<h3 id="发布到服务器"><a href="#发布到服务器" class="headerlink" title="发布到服务器"></a>发布到服务器</h3><p>本项目已实现自动发布，推送后就会自动发布到<a href="https://segmafrontend.github.io/">西格马技术分享</a></p>
<h4 id="如需手动发布可执行以下操作"><a href="#如需手动发布可执行以下操作" class="headerlink" title="如需手动发布可执行以下操作"></a>如需手动发布可执行以下操作</h4><p>生成静态文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p>
<p>或者简写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></p>
<p>部署到服务器<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>或者简写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p>
<p>如果更新没有生效请使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title>git clone命令速度很慢解决方案</title>
    <url>/2018/09/11/git-clone%E5%91%BD%E4%BB%A4%E9%80%9F%E5%BA%A6%E5%BE%88%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们日常工作中使用git clone命令时速度非常慢，一个几M的项目都需要十几分钟，速度也就10kb/s-20kb/s，很让人着急，严重影响工作效率。<br>这里提出一种解决方案，希望可以帮助大家解决烦恼<br><a id="more"></a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>翻墙工具（SS、蓝灯之类，你懂的）</li>
<li>命令行工具</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>打开你的代理工具，找到本地代理的地址和端口，例如我的蓝灯：<br><img src="https://i.loli.net/2018/09/11/5b97214541784.png" width="400" align="center"></p>
<p>方案1、打开命令行工具，输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global http.proxy http://127.0.0.1:52951</span><br><span class="line">$ git config --global https.proxy https://127.0.0.1:52951</span><br></pre></td></tr></table></figure></p>
<p>方案2、或者编辑.gitconfig文件，windows系统在C:\Users\你的用户名这个文件夹下,mac用户执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vi ~/.gitconfig</span><br></pre></td></tr></table></figure></p>
<p>  在文件最后添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[http]</span><br><span class="line">  proxy = http://127.0.0.1:52951</span><br><span class="line">[https]</span><br><span class="line">  proxy = https://127.0.0.1:52951</span><br></pre></td></tr></table></figure></p>
<h3 id="再试一下git-clone，速度杠杠滴！"><a href="#再试一下git-clone，速度杠杠滴！" class="headerlink" title="再试一下git clone，速度杠杠滴！"></a>再试一下git clone，速度杠杠滴！</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>工欲善其事必先利其器，简单的优化就能帮助我们提升开发效率！</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
