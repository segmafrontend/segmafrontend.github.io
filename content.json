{"meta":{"title":"思考的豆芽","subtitle":"技术分享","description":null,"author":"豆芽","url":"https://segmafrontend.github.io"},"pages":[{"title":"分类","date":"2018-09-10T07:48:22.000Z","updated":"2021-05-27T07:22:41.770Z","comments":false,"path":"categories/index.html","permalink":"https://segmafrontend.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-10T07:45:16.000Z","updated":"2021-05-27T07:22:41.770Z","comments":false,"path":"tags/index.html","permalink":"https://segmafrontend.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis延时队列","slug":"redis延时队列","date":"2021-05-10T08:00:00.000Z","updated":"2021-05-27T07:56:19.196Z","comments":true,"path":"2021/05/10/redis延时队列/","link":"","permalink":"https://segmafrontend.github.io/2021/05/10/redis延时队列/","excerpt":"redis延时队列基本原理利用redis的Sorted Set有序集合数据结构实现 订单创建时，订单id和当前时间戳作为Sorted Set 的value和score 定时通过zrangebyscore返回指定score区间内的订单进行处理 通过zrem保证只有一个消费者能从Sorted Set中删除元素，删除成功消费者就可以执行任务了【","text":"redis延时队列基本原理利用redis的Sorted Set有序集合数据结构实现 订单创建时，订单id和当前时间戳作为Sorted Set 的value和score 定时通过zrangebyscore返回指定score区间内的订单进行处理 通过zrem保证只有一个消费者能从Sorted Set中删除元素，删除成功消费者就可以执行任务了【 取消未付款订单/确认收货实现 加入队列 启动系统时，扫描未付款/已发货未收货的订单，将订单id和创建/发货时间加入队列 创建订单/发货时，添加当前订单的id和时间进入队列 移除队列 用户在设定时间范围内完成付款/收货，从队列中移除任务 到达设定时间，消费者删除任务然后执行任务(取消订单/确认收货)","categories":[{"name":"note","slug":"note","permalink":"https://segmafrontend.github.io/categories/note/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://segmafrontend.github.io/tags/redis/"}]},{"title":"JavaScript继承","slug":"JavaScript继承","date":"2021-04-11T08:00:00.000Z","updated":"2021-05-27T07:52:31.740Z","comments":true,"path":"2021/04/11/JavaScript继承/","link":"","permalink":"https://segmafrontend.github.io/2021/04/11/JavaScript继承/","excerpt":"JavaScript继承原型链 普通对象有__proto__和constructor 函数也是对象，没有constructor，独有prototype属性","text":"JavaScript继承原型链 普通对象有__proto__和constructor 函数也是对象，没有constructor，独有prototype属性 原型链继承优点：原型链上的属性和方法都可以被继承 缺点：子类无法向父类传参 1234567891011121314151617// 父类构造函数function Father() &#123;&#125;;// 用于共享的方法和属性放到原型对象上Father.prototype.say = function(msg) &#123; console.log('msg: ', msg);&#125;Father.prototype.type = 'father';// 子类构造函数function Son(name) &#123; // 用于子类的属性和方法放到函数体内，不在原型链上 this.name = name;&#125;;Son.prototype = new Father(); // Son.prototype.__proto__ = Father.prototype// Son.prototype.type = 'father';// 实例化var p1 = new Son('cz');p1.say('may name is '+p1.name+',my type is '+p1.type); 借用构造函数/经典继承优点：子类可以向父类传参 缺点： 只能继承父类的实例方法和属性，无法继承原型属性和方法 使用call实际上是对父类的复制，每个新实例就会复制一份 12345678910function Father(age) &#123; this.name = 'father'; this.age = age;&#125;;function Son(age) &#123; Persion.call(this, age); // 借用另一个构造函数的对象和方法的构造 // 相当于 this.name = 'father'; this.age = age;&#125;var one = new Son(18); // &#123; name: 'father', age: 18 &#125; 组合继承结合原型链和经典继承 12345678910function Father(age) &#123; this.name = 'father'; this.age = age;&#125;Father.prototype.say = function(msg) &#123; console.log(msg) &#125;;function Son(age) &#123; Father.call(this, age); // 借用Persion的属性和方法&#125;Son.prototype = new Father();var one = new Son(18); 原型式继承对象浅复制，增加一层__proto__的引用，Object.create()的实现 浅复制父类的原型对象作为子类的原型对象即可实现继承 12345678910111213141516function createObj(obj) &#123; function F() &#123;&#125;; F.prototype = obj; return new F();&#125;// obj1 = new Father();// obj2 = createObj(obj1); // 基于obj1创建对象obj2function Son() &#123; this.name = 'son';&#125;;// Son.prototype = Object.create(Father.prototype);Son.prototype = createObj(Father.prototype);Son.prototype.constructor = Son;var son = new Son();console.log(son.name); // sonson.say('hello'); // hello，继承了父类的原型方法 寄生继承寄生：函数内返回返回对象，然后调用函数 对原型式继承二次封装，对原型式继承生成的对象进行扩展后返回 12345678910111213function creatAnother(origin) &#123; var clone = createObj(origin); clone.sayHi = function() &#123; console.log('Hi'); &#125; return clone;&#125;obj1 = &#123; name: 'obj1'&#125;obj2 = creatAnother(obj1);console.log(obj2.name); // 'obj1'obj2.sayHi(); // Hi 寄生组合式继承组合式继承中将父类的实例赋值给子类的原型对象的操作改为使用原型继承的方式浅复制一份父类的原型对象作为子类构造函数的原型对象 1234567891011121314function createObj(obj) &#123; function F() &#123;&#125;; F.prototype = obj; return new F();&#125;function Son(age) &#123; Father.call(this, age);&#125;;Son.prototype = createObj(Father.prototype);Son.prototype.constructor = Son;var son = new Son(18);console.log(son.name); // fatherconsole.log(son.age); // 18son.say('hello'); // hello，继承了父类的原型方法","categories":[{"name":"note","slug":"note","permalink":"https://segmafrontend.github.io/categories/note/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://segmafrontend.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://segmafrontend.github.io/tags/vue/"}]},{"title":"JavaScript模块规范","slug":"JavaScript模块规范","date":"2021-03-10T08:00:00.000Z","updated":"2021-05-27T07:52:31.747Z","comments":true,"path":"2021/03/10/JavaScript模块规范/","link":"","permalink":"https://segmafrontend.github.io/2021/03/10/JavaScript模块规范/","excerpt":"JavaScript模块规范CommonJSNode.js和Webpack采用CommonJS编写，包括： 模块引入(require)，用于加载模块 模块定义(exports)，对外的接口，加载模块其实就是加载module.exports属性(Node中每个模块exports即为module.exports，不要对exports重新赋值，只能添加属性) 模块标识(module)，在模块内代表当前模块","text":"JavaScript模块规范CommonJSNode.js和Webpack采用CommonJS编写，包括： 模块引入(require)，用于加载模块 模块定义(exports)，对外的接口，加载模块其实就是加载module.exports属性(Node中每个模块exports即为module.exports，不要对exports重新赋值，只能添加属性) 模块标识(module)，在模块内代表当前模块 特点： 独立作用域 同步引入 首次加载时require时运行，再次加载直接取缓存结果，要再次运行需要清除缓存 require命令 加载并执行一个js文件，返回exports属性 参数可以为绝对路径、相对路径、文件名，文件名查找顺序node安装目录-&gt;当前目录node_modules-&gt;逐级向上的node_modules require.main === module，可以在模块内判断模块是直接执行(true)还是require加载执行 require源码解析 循环加载A加载B，B又加载A，那么B加载的将是A已经执行的部分，例如： 123456789// A.jsmodule.exports.x = 'a1';require(./B.js); // 执行到这里就会加载B.jsmodule.exports.x = 'a2';// B.jsmodule.exports.x = 'b1';require(./A.js); // 执行到这里只会加载A.js在加载B.js之前已经执行的第一句，返回一个&#123; x: 'a1' &#125;的对象module.exports.x = 'b2'; AMDAsynchronous Module Definition，异步模块定义，依赖前置原则，主要用于浏览器，RequireJS 在推广过程中对模块定义的规范化产出 定义模块语法[dependencies], factory)```12345678910- id，模块标识- dependencies，依赖的模块的名称数组，依赖前置，先解决依赖才会执行factory方法- factory，工厂方法，初始化模块需要执行的函数或者对象，函数参数为依赖的模块，为对象时为模块的输出值### 加载模块需要引入require.js后使用require方法```require([dependencies], fucntion()&#123;&#125;) 示例1234567891011121314151617181920212223242526// base.jsdefine(function() &#123; return &#123; base: function() &#123;&#125; &#125;&#125;)// ui.jsdefine(['base.js'], function(base) &#123; return &#123; initPage: function() &#123;&#125; &#125;&#125;)// page.jsdefine(['base.js', 'ui.js'], function(base, ui) &#123; // ...&#125;)// data.jsdefine(&#123; users: [], numbers: []&#125;)// 兼容CommonJS规范define(function(require, exports, module) &#123; var base = require('base.js'); module.exports.show = function() &#123;&#125;;&#125;) CMDCommon Module Definition，通用模块定义，依赖就近原则，是SeaJS 在推广过程中被广泛认知。 定义模块语法123456789101112131415161718192021222324252627282930- factory，可以为字符串、对象、函数等- 为函数时就是模块的构造方法，function(require, exports, module) &#123;&#125;- 构造方法内require为同步加载，require.async(dependencies, function()&#123;&#125;)为异步加载## UMD兼容CommonJS和AMD规范## ES6- 静态化，ES6在编译时确定依赖关系而不是CommonJS和AMD的运行时，所以引入是不能是表达式- ES6的模块并不返回一个对象，通过export和import导出和引入- 提升效果，可以在引入前使用```javascript// CommonJSlet &#123; aaa, bbb &#125; = require(&apos;math&apos;);// 相当于let tmp = require(&apos;Math&apos;);let aaa = require.aaa;let bbb = require.bbb;// ES6import &#123; aaa, bbb &#125; from &apos;math&apos;;// aaa, bbb必须和模块中导出的变量同名// export和import时都可以使用as对变量重命名，使用*表示整个模块// 模块内使用export default匿名导出，引用时可以自己命名模块import anyname from &apos;math&apos;;","categories":[{"name":"note","slug":"note","permalink":"https://segmafrontend.github.io/categories/note/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://segmafrontend.github.io/tags/javascript/"}]},{"title":"学习笔记","slug":"学习笔记","date":"2020-09-23T08:00:00.000Z","updated":"2023-10-26T01:13:26.646Z","comments":true,"path":"2020/09/23/学习笔记/","link":"","permalink":"https://segmafrontend.github.io/2020/09/23/学习笔记/","excerpt":"学习笔记一些js的基础知识","text":"学习笔记一些js的基础知识 中台概念传统前台-后台架构，各个项目相对独立，各自造各自的轮子，会使项目越来越臃肿，开发效率越来越低。出现大量重复开发，用户体验不统一，无法支持大规模的用户增长等问题。 为了提高开发效率，就提出将需求高度相似、通用程度高的业务由专门的团队负责规划和开发。也就是一个专门造轮子的部门。 举例数据中台：统一对数据进行采集、数据集成、数据治理，统一标准和口径，让数据产生更多的价值。它的本质就是“数据仓库+数据服务中间件”，作为各个业务的数据源，为业务系统提供数据和计算服务。 业务中台：各个项目的共同业务整合成统一的服务平台，例如支付、用户等等 技术中台：为各个项目的开发人员提供通用的底层框架、引擎等 算法中台：为各个项目提供算法能力，搜索、推荐、图像识别等等 Iaas基础设施服务\\Paas平台服务\\Saas软件服务Iaas: 就是提供服务器、存储、网络等硬件支持服务 Paas: 软件部署平台，开发组只需要关心业务逻辑，不用关心底层实现 Saas: 软件服务，就是拿来即用的，不需要关心技术 JavaScript相关执行上下文和执行栈执行上下文：分全局和函数执行上下文，函数被调用时创建一个执行上下文，按被定义的顺序执行；不在函数中的代码均在全局上下文中执行，会创建一个window对象并让this指向这个对象。 执行栈: LIFO（后进先出），执行一段程序，先创建全局上下文，遇到一个函数调用就创建一个函数上下文压入执行栈顶部，引擎执行完一个函数就会将它弹出执行栈。 执行上下文分为创建阶段和执行阶段 创建阶段分三个步骤： this的绑定 创建词法环境 创建变量环境 this的值this的值取决于函数是如何被调用的，如果是被一个引用它的对象调用，那么this的值就是这个对象，否则就是全局对象或者undefiend（严格模式）。eg: obj.fn()的fn中的this就是obj，但是bar=obj.fn;bar()中的this就是全局了。 由new调用：绑定到新创建的对象 由call或apply、bind调用：绑定到指定的对象，[].slice(argument)相当于arugment.slice() 由上下文对象调用：绑定到上下文对象 默认：全局对象 注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定this，继承外层函数调用的this绑定。 词法环境定义标识符（变量名称）和变量/函数之间的关联，一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。全局环境中外部环境引用为null，有内建的Object/Array等函数；函数环境中用户定义的变量存储在环境记录器中，外部环境引用为全局或者包含此函数的外部函数。每个函数对父级作用域的引用构成了作用域链。 变量环境也是一个词法环境，和词法环境的区别就是用来记录var定义的变量，且初始值设为undefined。 函数的作用域取决于函数创建的位置，而不是执行的位置，就是静态作用域 变量提升编辑节点，代码执行前，所有变量和函数的声明会被添加到词法环境中，所有可以在声明的代码前访问到变量和函数。但是，声明和赋值是两步操作，声明会被提升，赋值不会 1234567var myname = 'chenz';function getName() &#123; // 函数内部没有声明就会向上查找到window.myname，后面语句中的变量声明会被提升，所以访问的是内部的myname console.log(myname); if(0) &#123; var mayname = 'xxx' &#125; // 条件中的语句虽然不会被执行，但是声明会被识别到，只是没有被赋值 console.log(myname);&#125; 原型与原型链 一个以隐式引用作为存储方式，以点操作符和属性访问语句作为语法糖的单向链表。 构造函数、实例对象、原型对象js中万物皆对象，分为普通对象和函数对象 普通对象添加prototype属性就是原型对象 函数对象创建时就会自带prototype属性 构造函数就是设计图，实例对象就是生产的产品 实例对象的proto就是构造函数的prototype，也就是原型对象 实例对象的constructor就是proto的constructor，也就是原型对象的constructor 原型prototype，就是给其它对象提供共享属性的对象，prototype 描述的是两个对象之间的某种关系（其中一个，为另一个提供属性访问权限）。 对象的__proto__属性实际上指向它的prototype对象的proto的get()方法。 每个对象都有一个__proto__属性，指向构造函数的prototype对象 每个对象都有自己的__proto__，构成了对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。 原型的继承Object.setPropertyOf 和 Object.create都可以实现原型的显式继承（即手动继承），区别在于： Object.setPrototypeOf，给我两个对象，我把其中一个设置为另一个的原型。 Object.create，给我一个对象，它将作为我创建的新对象的原型。 JavaScript 提供了隐式的原型继承方式，实现了下面这几个步骤： 创建空对象 设置该空对象的原型为另一个对象或者 null 填充该对象，增加属性或方法。 通过 new 去创建 user 对象，可以通过 user.consturctor 访问到它的构造函数。 1234567// constructor函数function User(firstName, lastName) &#123; this.firstName = fristName; this.lastName = lastName;&#125;const user = new User(&apos;zeng&apos;, &apos;chen&apos;);console.log(user.constructor === &apos;User&apos;); // true 实际javasscript会隐式的完成完成创建对象、原型继承和属性初始化的过程 1234const user = &#123;&#125;;Object.setPrototypeOf(user, User.prototype);user.firstName = &apos;chenz&apos;;user.lastName = &apos;zeng&apos;; 使用对象字面量创建对象 1234const user = &#123; firstName: &apos;chen&apos;, lastName: &apos;zeng&apos;,&#125; 等价于 123const user = new Object();user.firstName = &apos;chen&apos;;user.lastName = &apos;zeng&apos;; 继承原型链继承子类构造函数的原型指向父类构造函数 缺点: 父类的属性被所有子类共享 创建子类时无法向父类传参 借用构造函数（经典继承）子类构造函数的this通过call指向父类构造函数，解决了原型链继承的问题 缺点： 只能继承父类属性/方法，不能继承父类原型属性/方法 方法都在构造器中定义，每次创建实例都要创建一遍方法 组合继承用原型链继承实现对原型属性/方法的继承，用借用构造函数来实现对实例属性/方法的继承 缺点： 两次调用父类构造函数 设计模式工厂模式简单工厂模式又叫静态工厂模式，用于创建同一类产品的实例，根据传入的参数不同，创建的实例的属性就不同。 常用场景：用户权限（根据传入角色返回不同的实例）、vue-router（不同角色配置不同的路由） 12345678910111213141516171819202122function Factory(name,age)&#123; let person = &#123;&#125;; person.name = name; person.age = age; person.say = function()&#123; return this.name; &#125;; return person;&#125;let tom = new Factory(&apos;Tom&apos;,&apos;10&apos;);let jerry = new Factory(&apos;Jerry&apos;,&apos;20&apos;);// ES6class Factory &#123; //构造器 constructor(opt) &#123; this.name = opt.name; this.age = opt.age; &#125; say() &#123; return this.name; &#125;&#125; 工厂方法模式抽象一个工厂用于创建一个工厂，将其成员对象的实例化推迟到子类中，子类可以重写父类接口方法以便创建时指定独自的对象类型，父类变为抽象类，不能被实例只能被继承。这样的好处是通用方法写在工厂函数中，不需要重复实现，不同个性化代码在子类中实现。 就是将简单工厂模式中的通用部分提取到一个父类中。 1234567891011121314151617181920class User &#123; constructor(opt = &#123;&#125;) &#123; if(new.target === User) &#123; throw new Error(&apos;抽象类不能实例化!&apos;); &#125; this.name = opt.name; this.age = opt.age; &#125; say() &#123; return this.name; &#125;&#125;class Factory extends User &#123; constructor(opt) &#123; super(opt); &#125; create(opt) &#123; return new Factory(opt); &#125;&#125; 单例模式针对全局仅需一个对象的场景，如线程池、全局缓存、window 对象等。 1234567891011121314151617181920let CreateSingleton = (function()&#123; let instance; return function(name) &#123; if (instance) &#123; return instance; &#125; this.name = name; return instance = this; &#125;&#125;)();CreateSingleton.prototype.getName = function() &#123; console.log(this.name);&#125;let Winner = new CreateSingleton(&apos;Winner&apos;);let Looser = new CreateSingleton(&apos;Looser&apos;);console.log(Winner === Looser); // trueconsole.log(Winner.getName()); // &apos;Winner&apos;console.log(Looser.getName()); // &apos;Winner&apos; 观察者模式定义了一种对象之间的一对多的关系，只要当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，解决了主体对象与观察者之间功能的耦合，即一个对象状态改变给其他对象通知的问题。常用的DOM事件绑定就是一种观察者模式。 12345678910111213141516// 主体对象class SubjectObj &#123; constructor() &#123; this.observers = []; // 观察者列表 this.internalState = 10; &#125; // 更新状态，触发观察者对象更新 notify(value) &#123; this.internalState = value; this.observers.forEach(observerFn =&gt; observerFn(value)); &#125; // 注册观察者 registerObserver(observerFn) &#123; this.observers.push(observerFn); &#125;&#125; 发布-订阅模式类似于观察者模式，但是多了一个中间层，增加了消息队列，改为异步推送。 模块化全局方法 –&gt; 对象封装 –&gt; 自调用函数(闭包) –&gt; script引入 好处： 避免命名冲突 按需加载 更好维护 更好复用 问题： 请求过多 依赖关系混乱 为了解决这些问题，产生了模块化规范commonJS、AMD、CMD commonJSNode采用的规范，一个文件就是一个模块，其中的变量、方法都是私有的。服务器端是同步加载的，客户端需要编译。 暴露模块：module.exports = value或者exports.xxx = value，module在模块内部代表模块本身 引入模块：require()，调用是读入并执行一段Javascript并查找exports属性，没找到会报错 输入的值为输出值的拷贝，如果是一个原始类型的值，模块内部值的变动就不会影响已经引入的值 加载模块为同步加载，只有加载完成了才能进行下一步操作，比较适合服务器端，因为文件都是本地加载 AMD异步模块加载，RequireJS定义的规范，使用define方法进行模块的定义 123// 数组引入依赖，回调参数为引入的依赖// 依赖前置，一开始就引入了依赖define([module1, module2], function(module1, module2) &#123;&#125;) CMD延迟模块加载，与AMD的主要区别： AMD为提前执行，CMD为延迟执行 AMD为依赖前置，CMD为依赖就近 123456789define(function(require, exports, module)&#123;// requre用于引入依赖//引入依赖模块(同步) var module2 = require(&apos;./module2&apos;)//引入依赖模块(异步) require.async(&apos;./module3&apos;, function (m3) &#123;&#125;)// exports、module用于暴露模块exports.xxx = value;&#125;) 跨域浏览器同源策略，“协议+域名+端口”必须相同，才能访问资源，三者中任意一个不同的情况访问资源都算作“跨域” 前端只能实现域名不同的跨域。 请求实际已经发出去了，只是返回时浏览器如果判断是跨域请求，就拦截了，所以无法完全阻止CSRF(跨站请求伪造) 不受跨域限制： img的src link的href script标签的src jsonp利用script标签src不受跨域限制实现的跨域方案，动态获取json数据。 缺点：类似于同源的ajax，但是只支持get方法，有局限性，且容易遭受xss攻击(跨站脚本攻击) PS：xxs攻击，就是在本应是文本的地方输入/传入一段脚本，从而达到攻击的目的， 存储型，持久，只要访问存储有恶意代码的数据，就会被攻击 反射型，非持久，只有访问特定的URL才会被攻击 危害： 劫持访问，跳转到其他页面 盗取cookie，实现无密码登录，可使用验证码、http-only cookie进行防范(禁止Javascript访问cookie) 配合CSRF，实现修改密码、银行转账等，可通过原密码校验、短信验证码等进行防范 防范： 过滤用户输入，对能实现xss的script、img、a等标签进行过滤 字符转义，让浏览器正确显示字符的同时不作为代码执行 限制用户输入，对于可预期的输入进行限制，例如邮箱、电话号码等 深浅拷贝深浅拷贝主要针对引用型数据，浅拷贝只拷贝引用不拷贝值 = 赋值操作符是浅拷贝 JSON.stringify()和JSON.parse()转换可以实现深拷贝，但是不能拷贝属性是function/undefined/symbol 数组/对象自带的拷贝方法均是首层浅拷贝，只有第一层是深拷贝，二维就是浅拷贝了 只能递归才能实现真正的深拷贝 事件机制 Event Table 用于注册异步回调ß Event Queue 事件队列，主线程空闲时就会执行队列中的任务 主线程是唯一的，但是事件队列可以有多个，分宏任务和微任务，process.nextTick和Promise属于微任务，setTimeout本身属于宏任务在第一轮循环执行注册回调，然后微任务，然后第二轮执行宏任务执行回调。 柯里化柯里化，就是将一个多参数的函数，转换成一系列使用一个参数的函数 作用：参数复用，对于多次调用同一个函数的情景，使用柯里化转换后的函数，相同的参数就不用重复传了 1234567891011121314// 将普通函数柯里化function curry(func) &#123; return function curried(...args) &#123; // func.length表示func这个普通函数的参数个数 if (args.length &gt;= func.length) &#123; return func.apply(this, args); &#125; else &#123; return function(...args2) &#123; // curriedFn(a)(b,c)的场景，concat后再次调用参数就是(a,b,c)了，走第一个if return curried.apply(this, args.concat(args2)); &#125; &#125; &#125;;&#125; promise回调函数：a函数作为参数传给b函数，需要依赖b函数的调用，容易嵌套层数过多引起混乱 JavaScript异步解决方案 一个Promise对象有三种状态，只能从pendding到另外一种状态，且变更后凝固不再变化 Pending 进行中 Fulfilled 已完成 Rejected 已拒绝 Promise对象 的then()方法接收一个函数参数，函数的两个参数分别是onFulfilled和onRejected，返回一个新的Promise(因为原来的Promise状态已经凝固) catch()方法是then(null/undefined, onRejected)的别名，捕获reject()和then的回调中的错误，错误会“冒泡”，最后的catch会捕获前面所有的错误 构造函数Promise()接收两个方法参数，resolve()方法将Pending变更为Fulfilled，reject()方法将Pendding变更为Rejected 构造函数中的代码将会立即执行，then()方法中的代码总是异步执行 立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务 Promise.allSettled()，接收数组，所有promise都finally才返回结果，只会变为Fulfilled，回调参数为数组 函数式编程就是声明各种纯函数，拼接成管道来完成任务 数据不可变，不会修改已有的数据(外部变量)，新增进行处理 无状态，函数输出只取决于传入的参数，不依赖外部 打包工具gulp基于流的打包工具，可以自动执行指定的任务 定义的是构建前端的流程，给图片压缩、文件压缩合并、启动server、版本控制等一系列任务设置顺序。 webpack模块化打包工具，提供一个核心，通过loader（加载器）和plugins（插件）扩展核心，对资源进行处理，打包成符合生产环境部署的前端资源。可以将所有资源视为模块，如图片、视频、AMD模块、ES6模块、CSS等等，给模块设置依赖关系和规则实现打包，可以实现模块的按需加载。 动态import：import()是一个类函数的用法，但不是真正的函数，返回一个promise。编译时时遇到import()，webpack会对代码进行分割，生成一个chunk，再进行babel转换，运行时需要用到才会加载对应的chunk文件。可以通过命名chunk将不同的组件代码打包到同一个chunk中。 loader和pluginloader主要负责转换代码，例如sass-loader、babel-loader、file-loader、url-loader等等 plugin主要负责处理代码，混淆、压缩、分包、提高效率等等，挂载wepack事件钩子触发，返回一个构造函数，例如html-webpack-plugin、UglifyJsPlugin(混淆)、HotModuleReplacementPlugin(热更新)等等 编译流程流程：参数解析 -&gt; 入口文件 -&gt; loader编译 -&gt; -&gt; -&gt; 输出 Compiler类，全局只会有一个它的实例，包含完整的webpack配置，负责文件的监听和编译的启动。 Compilation类，开发模式每一次文件变更就会生成一个新的Compilation实例，包含当前模块资源、生成的资源、变化的文件等 配置懒加载本来webpack只负责预编译模块，生成浏览器可以识别的代码；后来通过plugins也实现了gulp的代码处理工作。 CI/CD通过定义pipeline，其中设置多个job来配置 CI - 持续集成提交代码合并入主分支前，自动进行一系列测试、打包构建等工作 CD - 持续部署在集成了基础上，自动实现将代码部署到生产环境 CDN无CDN，前端资源均存储在服务器上，访问用户多了服务器压力就会很大；而且不同地域访问收到网络速度的显示体验会相差很大。利用CDN(内容分发网络)将资源缓存到距离用户最近的运营商CDN节点中，就可以解决以上问题。 路由后端路由后端解析url，根据服务器配置，返回html、json、图片等，浏览器通过返回的 Content-Type 来决定如何解析数据 前端路由解析url，动态加载页面内容， hash模式修改url，会发送请求，造成页面的刷新，但是修改url的hash就不会，修改hash会触发hashchange事件，监听事件就可以实现动态加载页面内容了 history模式HTML5标准支持通过pushstate和replacestate修改url不会发送请求触发页面刷新，通过popstate事件监听实现动态加载页面内容 缺点：用户手动刷新页面会发送请求，可通过后端配置所有url重定向到根页面解决 Vue实现原理MVVM框架，核心是双向数据绑定实现。采用数据劫持结合发布订阅模式，通过Object.defineProperty()劫持数据对象属性的getter和setter监听数据的变更，发布给订阅者触发对应的回调。包括Observer数据监听、Compile指令解析、Watcher观察器。 虚拟DOM浏览器渲染引擎工作流程：创建 DOM 树 —&gt; 创建 Style Rules -&gt; 构建 Render 树 —&gt; 布局 Layout -—&gt; 绘制 Painting 虚拟DOM就是将真实的DOM用js模拟，然后将DOM变更的对比，放到js层面去做，将多次更新合并为一次，并且只更新发生了变更的节点，最大限度的减少DOM操作，从而显著的提高性能 手动操作DOM元素，每次操作都需要重新创建DOM树，非常浪费性能。 虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，再通过JS一次性attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量 Vue的diff算法和React的diff算法不同 Vue只对同一层的元素进行比对，复杂度较低 对象根属性添加vue对data对象的响应式处理是在实例初始化时进行的，手动添加data对象的属性就无法修改其setter和getter 解决方案：提前声明属性；Vue.set()/Vm.$set() 数组变更检测产生原因：Vue只对数组本身进行了相应式处理，不对内容处理，直接修改数组某一项的值或者length，Vue无法劫持数据，所以无法触发更新 解决方案：使用Vue.set()或者vm.$set()，或者变异方法 3.0更新基于Proxy的观察者，取代了基于Object.defineProperty的观察者，优点： 可以检测属性的新增和删除 可以坚持数组索引的变化和length的变化 支持Map、Set等 重写了虚拟DOM，提速100% React热更新原理： ES6CSS浏览器渲染构建DOM树，html解析 -&gt; style rules，生成样式表 -&gt; 构建render树，关联DOM和样式 -&gt; 布局layout，确定坐标 -&gt; 绘制 html解析、css构建、render树构建三者是交叉执行的，一边加载一边解析一边渲染 每操作一次DOM就需要从头来一遍，所以开销较大 盒模型CSS盒模型本质上是一个盒子，所有html元素都是盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容 IE盒模型，width/height包含content、border、padding W3C标准盒模型，width/height只包含content 可以通过设置box-sizing进行切换，border-box为IE盒模型，content-box为标准盒模型 块元素/行内元素 块元素新起一行，宽度默认100%；行内元素和其他元素在一行 块元素可以包含其他块元素/行内元素；行内元素只能包含文本/行内元素 块元素中高度、行高、上下边距等可以控制；行内元素不可以 文档流常规流、浮动流、绝对定位流 常规流 格式化上下文，一块渲染区域，决定子元素的布局以及和其他元素的关系 position为static/relative，并且float为none时，触发常规流 行内格式化上下文，从左到后排列 块级格式化上下文，从上到下排列 浮动流 float不为none触发浮动 浮动元素会影响行内格式化上下文，让行内元素围绕在浮动元素周围，撑大父元素，设置clear可以清除 绝对定位流 position为absolute/fixed，触发绝对定位流 盒从常规流中移除，根据left、right、top、bottom进行定位 absolute相对于上级元素中最近的一个relative、fixed、absolute的元素进行定位 fixed相对于viewport进行定位，一些让父级元素形成堆叠上下文的属性会导致相对于父级元素定位 块级格式化上下文(BFC - Block Formatting Context)一块独立的渲染区域，其中元素布局不受外界影响 触发方式： 根元素 浮动元素 overflow为auto、scroll、hidden时，不为visible display值为inline-block、flex、inline-flex、table、inline-table、table-cell、grid、inline-grid 绝对定位absolute、fixed display: flow-root，无副作用，还不是完全支持 约束规则： 子元素从上到下一个接一个排列，各自占一行 相邻两个子元素会外边距折叠(两正取最大/两负取最小/正负取和)；两个BFC之间不会折叠 不会与float元素区域重叠 计算BFC高度时，float元素也参与计算 作用： 防止被float元素覆盖 包含浮动元素 第一个/最后一个子元素与非BFC父元素之间如果没有border/padding，margin将会溢出父元素，BFC可以解决 多列布局防止最后一个元素因为宽度四舍五入换行 清除浮动浮动元素会脱离常规文档流，不影响它前面的元素，它后面的行内元素会围绕浮动元素，将其包含在其中 clear: both; 让元素周围都没有浮动元素，就会在浮动元素下方，可以间接达到撑开父元素的作用(父元素必须包含子元素) 常说的清除浮动其实是让浮动元素撑开父元素高度的意思，浮动元素会造成父元素高度塌陷，超出父元素的浮动元素会影响父级元素的兄弟元素的布局 父元素最后插入一个清除浮动的空元素/伪元素可以达到清除浮动同时撑开父元素高度的目的 父元素BFC，利用BFC会包含浮动元素的特性撑开父元素 垂直居中 已知高度，top: calc(50% - height/2);、top: 50%; margin-top: -height/2;、top: 0;bottom: 0;margin: auto; 高度未知，top: 50%; transform: translateY(-50%) 单行文本，line-height: 行高; 父元素为行内元素/table，vertical-align: middle; 父元素不要求高度，父元素padding: 100px 0; 图片，父元素设置line-height，图片设置vertical-align: middle; 像素、分辨率、缩放比","categories":[{"name":"note","slug":"note","permalink":"https://segmafrontend.github.io/categories/note/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://segmafrontend.github.io/tags/javascript/"}]},{"title":"Vue学习笔记","slug":"Vue学习笔记","date":"2020-05-15T08:00:00.000Z","updated":"2023-10-26T01:13:26.635Z","comments":true,"path":"2020/05/15/Vue学习笔记/","link":"","permalink":"https://segmafrontend.github.io/2020/05/15/Vue学习笔记/","excerpt":"VueMVVM在MVC的基础上实现了view-model，即视图与数据的双向绑定，视图只是数据的映射，所有逻辑都是对数据的修改，不用直接操作DOM。","text":"VueMVVM在MVC的基础上实现了view-model，即视图与数据的双向绑定，视图只是数据的映射，所有逻辑都是对数据的修改，不用直接操作DOM。 SPA单页应用优点： 具有桌面应用的即时反馈，无需刷新页面就可以交互，又有web的跨平台 后续操作无需重新从服务器获取静态资源，服务器压力较小 路由由前端控制，更好的前后端分离 缺点： 首屏加载资源较多，速度较慢（按需加载、懒加载） 需要手动实现导航的前进后退 不利于SEO（需手动优化） 周期new Vue() –&gt; init –&gt; $mount –&gt; compiler –&gt; render –&gt; vnode –&gt; patch –&gt; DOM 常用题目单向数据流父组件使用用prop和子组件进行通信，父级prop更新传递给子组件进行更新，反之则不行。子组件中不能修改prop，只能通过$emit一个事件通知父组件，由父组件更新prop来修改。 computed和watch的区别 计算属性，依赖于参与计算的其他属性值，会对计算结果进行缓存，依赖的值发生变更才会重新计算，主要为了获取到最新的值。 watch，当某个属性值发生变化时，触发对应的回调。更多的是在数据变化是执行异步操作/复杂操作， 而不是为了获取最新的值。 对象变更检测Vue是在初始化实例时对data对象上的property执行getter/setter转换实现检测变更的，直接添加根级别的property将无法触发更新。 可以通过以下方式添加： Vue.set(vm.someObject, b, 2)/vm.$set(vm.someObject, b, 2) this.someObject = Object.assign({}, this.someObject, { b: 2 }) 数组变更检测直接修改数组中一项的值，或者修改数组的length，Vue无法检测到数据的变更。因为Vue是通过数据劫持实现监控数据的，只对数组本身进行了处理，对内容并没有处理。 通过以下方式Vue可以检测到变更： 变异方法，Vue对数组的方法进行了处理，调用时即可检测变更，eg：splice、push、shift、pop、slice等 Vue.set()/vm.$set() 生命周期 创建实例 初始化事件/生命周期 初始化注入/校验，data和methods初始化完毕 编译模板，生成模板 挂载实例，创建vm.$e并l替换el 销毁实例 钩子函数 beforeCreate， created，最早可以操作data和methods的地方 beforeMount mounted，初始化完毕，渲染真是dom beforeUpdate，data变成最新值，但是还没有更新到dom updated beforeDestroy，data、methods、指令、过滤器、计算属性等可用 destroyed 父组件监听子组件钩子方法一：手动在子组件钩子中$emit 方法二：父组件使用@hook:mounted就可以实现 keep-alive抽象组件，不会渲染任何DOM，动态组件&lt;component :is=&quot;currentComponet&quot;&gt;&lt;/component&gt;切换时每次都会重新渲染组件，无法保存状态，使用keep-alive组件包裹，就可以实现状态的保存。 对应activated和deactivated两个钩子函数 使用include/exclude属性传入正则/字符串，就可以设置哪些组件缓存/不缓存 为什么组件中data是一个函数返回一个对象，而new Vue()中data是一个对象因为对象是引用类的数据，组件复用时，如果是data 是对象，修改单个组件时就会影响其他组件的值。 v-model语法糖，例如input元素使用v-model相当于使用value和input事件修改value 用在组件上，默认使用名为value的prop和input的自定义事件 组件通信 父 -&gt; 子，prop/ref/$children 子 -&gt; 父，$emit/$parent 兄弟，EventBus 隔代，$attrs/$listeners，子组件上v-bind=”$attrs”会向下传递props属性中未获取的父组件传下来的props;$listeners包含了作用于当前组件的所有事件 隔代，provide/inject，provide传递数据，inject获取数据 Vuex，状态管理模式，state存储状态，getter计算状态，mutation/action可预测的变更状态，响应式 SSR服务端渲染，Vue在服务端渲染html页面推送到浏览器进行展示 更好的SEO 更快的首屏加载 只支持beforeCreate和created两个钩子 占用更多的服务器资源 Router hash模式，修改url的hash值（location.hash）实现跳转，hashchange更改页面内容 history模式，HTML5 History API，pushState和replaceState修改url不会引起页面刷新，需要配置后台避免手动刷新404 abstract模式，不依赖于浏览器，通过数组模拟浏览器历史记录和功能 双向绑定实现 Observer监听器，对数据对象data进行遍历，使用Object.definePropery()添加getter和setter实现数据劫持，对data 的属性进行修改时就会触发setter Compiler解析器，解析模板指令，将模板中的变量替换为数据，解析指令给对应节点绑定更新函数，添加数据订阅器 Watcher订阅者，订阅Observer中的数据变更，找到对应的更新函数并调用 Dep订阅器，收集订阅者 数组变化检测通过重写数组的push、pop、shift、unshift、splice、sort、reverse等方法实现数据劫持，不能修改Array.prototype上的方法，通过一个对象使用Object.create()原型继承的方式继承Array.prototype，将变异方法添加到新对象上，然后将data的数组属性的proto设置为新对象即可。 虚拟DOM的优缺点优点： 短时间内多次修改操作可以合并成一次，较少渲染成本 框架的虚拟DOM对呀修改DOM进行了性能优化，比手动修改DOM开销更小 对比修改前后的虚拟DOM计算差异，避免渲染整个DOM树 实现双向数据绑定，修改数据即可自动修改视图，减少开发成本 跨平台，纯JS实现，不依赖浏览器，可以实现服务端渲染、weex开发等等 缺点： 多了一次运算，增加开销 虚拟DOM需要适配上层API，无法做到极致的性能优化 虚拟DOM实现原理 解析html，用js对象模拟DOM树，对真是DOM进行抽象 dff算法，比较修改前后DOM树的差异 patch算法，将差异部分应用到真正的DOM树 Key的作用vnode的唯一标记，可以更准确、更快的diff操作 解决不需要就地复用的场景 直接通过key取节点比遍历更快 优化 v-if和v-show v-for和v-if混用 computed和watch 长列表优化，无限滚动/可见区域渲染 销毁事件 懒加载，路由、图片、组件等 三方插件按需引入 CDN 压缩，webpack、nginx 组件化 sourceMap优化 浏览器缓存机制优化 使用过程中遇到的最大的问题 数组变更检测，变异方法解决 异步回调中this指向问题，箭头函数/变量获取this setInterval销毁 3.0proxy创建一个代理替代一个对象，对目标对象的所有操作都可以在代理中进行拦截，对数组同样有效。 可以直接检测对象，而不是对象的属性，可以检测到对象的添加和删除 检测数组的索引和长度的变更 支持Set、Map、WeakMap和WeakSet 改用typescript，对ts更友好","categories":[{"name":"note","slug":"note","permalink":"https://segmafrontend.github.io/categories/note/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://segmafrontend.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://segmafrontend.github.io/tags/vue/"}]},{"title":"centOS硬盘休眠","slug":"硬盘休眠","date":"2020-04-13T08:00:00.000Z","updated":"2021-05-27T07:44:50.039Z","comments":true,"path":"2020/04/13/硬盘休眠/","link":"","permalink":"https://segmafrontend.github.io/2020/04/13/硬盘休眠/","excerpt":"","text":"hdparm设置磁盘自动进入stanby的时间，可以达到节能的目的,但是如果程序频繁访问磁盘，会导致磁盘频繁的stanby然后唤醒，非常容易损伤磁盘12345# 查看磁盘当前电源状态hdparm -C /dev/sdb1# 设置磁盘进入stanby时间，value*5=分钟数# 设置磁盘闲置一分钟进入stanbyhdparm -S 12 /dev/sdb1 smartctl检查磁盘的smart信息，详细解释看这里，主要看Load/Unload Cycle Count表示磁头加载/卸载的次数，新台式机硬盘设计寿命一般可达一百万次。1smartctl -a /dev/sdb1 西部数据硬盘主要为windows/macOS设计，默认8s没有操作就会自动将磁头卸载，已达到节能降低噪音的目的，但是作为NAS存储盘使用，并不会持续访问硬盘，而是某些服务间隔几秒访问一次，就会导致磁头不停的加载卸载，大约3分钟就会增加1次。算下来一个硬盘只能使用231天。为了延长硬盘寿命，有以下两种方案： 控制系统服务访问硬盘，按需访问。 增加硬盘自动卸载的间隔时间到几分钟。 因为需要使用nextcloud私有云服务，方案一实现起来很困难，所以采用方案二，安装idle3-tools软件修改硬盘卸载时间。 idle3-tools这是一个替代官方wdidle3.exe的第三方软件，专门用于修改西部数据硬盘的磁头自动停靠时间。附: 官方文档123456# 查看当前值idle3ctl -g /dev/sdb1# 修改值为300s，1-128为0.1秒一个单位，129-255为30秒一个单位idle3ctl -s 138 /dev/sdb1# 禁用自动停靠idle3ctl -d /dev/sdb1 修改成功后需要完全关闭机器，再打开才能生效。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://segmafrontend.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://segmafrontend.github.io/tags/Linux/"},{"name":"NAS","slug":"NAS","permalink":"https://segmafrontend.github.io/tags/NAS/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2020-02-29T08:00:00.000Z","updated":"2021-05-27T07:44:50.038Z","comments":true,"path":"2020/02/29/linux常用命令/","link":"","permalink":"https://segmafrontend.github.io/2020/02/29/linux常用命令/","excerpt":"vimctrl+b向上翻页ctrl+f向下翻页v进入视图模式，实现多选ctrl+v进入列视图模式，实现多列选中I列视图模式多列输入，需要返回命令模式才会应用","text":"vimctrl+b向上翻页ctrl+f向下翻页v进入视图模式，实现多选ctrl+v进入列视图模式，实现多列选中I列视图模式多列输入，需要返回命令模式才会应用 文件操作压缩压缩1tar -cvf abc.tar abc 解压缩1tar -xvf abc.tar du -h --max-depth=0 folder查看文件夹大小 移动合并文件夹12rsync -av folderA folderBrm -rf folderA 命令行history查询输入命令历史history number最近的多少条记录!!执行上一条命令!numer执行指定命令ctrl+r搜索历史记录，搜索后继续按ctrl+r可翻页ßctrl+u清空当前输入nohup command &amp;nohup表示退出后仍然运行，&amp;表示后台运行,文档jobs -l查看当前终端后台进程ps -aux查看进程,a所有程序,u用户为主,x不区分终端,文档ctrl+z进程放到后台并暂停bg &lt;number&gt;继续后台已经暂停的进程fg &lt;number&gt;后台进程放到前台 系统yum install -y &lt;软件名&gt;安装卸载软件 yum history list &lt;软件名&gt;查看安装记录，变更数为依赖数 yum history undo &lt;ID&gt;卸载软件以及依赖top查看系统状态，按m以内存排序dockerdocker system df查看docker镜像容器磁盘占用，-v参数查看详情","categories":[{"name":"Linux","slug":"Linux","permalink":"https://segmafrontend.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://segmafrontend.github.io/tags/Linux/"}]},{"title":"RN填坑记录","slug":"RN填坑记录","date":"2019-09-19T08:00:00.000Z","updated":"2021-05-27T07:52:31.712Z","comments":true,"path":"2019/09/19/RN填坑记录/","link":"","permalink":"https://segmafrontend.github.io/2019/09/19/RN填坑记录/","excerpt":"网络调试，开启网络调试后，发送请求无法正常返回数据，response为空，需要关闭后恢复正常 安卓获取权限，在AndroidManifest中声明的，在android 6.0之前直接就可以获取，在之后一些敏感的权限（定位、文件、相机等）需要先声明然后使用PermissionsAndroid动态获取（弹窗让用户确认）。可根据用户是否选择不再提醒要求用户到系统设置中修改。 formData无法使用，需要在app.js中加入以下代码","text":"网络调试，开启网络调试后，发送请求无法正常返回数据，response为空，需要关闭后恢复正常 安卓获取权限，在AndroidManifest中声明的，在android 6.0之前直接就可以获取，在之后一些敏感的权限（定位、文件、相机等）需要先声明然后使用PermissionsAndroid动态获取（弹窗让用户确认）。可根据用户是否选择不再提醒要求用户到系统设置中修改。 formData无法使用，需要在app.js中加入以下代码 1global.FormData = global.originalFormData MAC开发RN项目用xCode需要打开.xcworkspace文件无法找到模拟器错误1error Could not find \"iPhone X\" simulator 运行时指定模拟器版本解决1react-native run-ios --simulator=\"iPhone 11\" react-native run-android报错spawnSync ./gradlew EACCES通过修改./gradlew文件的权限解决1chmod 755 android/.gradlew pod install报错443，执行下面语句解决1pod repo remove trunk &amp;&amp; pod install 1Undefined symbols for architecture x86_64 无法启动react-native-config，无法使用pod install安装，需要删除Podfile中react-native-config相关行，然后手动link12// Podfile- pod 'react-native-config', :path =&gt; '../node_modules/react-native-config' 123yarn add react-native-configreact-native link react-native-configreact-native run-ios native module cannot be null，某些第三方包(react-native-amap3d)用到了源生模块，但是没有正确的配置造成的12345678// AppDelegate.m#import &lt;AMapFoundationKit/AMapFoundationKit.h&gt;...&#123; [AMapServices sharedServices].apiKey = @\"你的高德 Key\"; RCTBrige ....&#125;","categories":[{"name":"React Native","slug":"React-Native","permalink":"https://segmafrontend.github.io/categories/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://segmafrontend.github.io/tags/React-Native/"}]},{"title":"安装centOS7搭建NAS记录","slug":"安装centos7搭建NAS记录","date":"2019-09-19T08:00:00.000Z","updated":"2021-05-27T07:44:50.039Z","comments":true,"path":"2019/09/19/安装centos7搭建NAS记录/","link":"","permalink":"https://segmafrontend.github.io/2019/09/19/安装centos7搭建NAS记录/","excerpt":"","text":"下载ISO镜像镜像分为标准、最小(Minimal)、桌面(Gnome)、网络(NetInstall)、完整(Everything)等几个版本，带live 的版本只会在内存中运行不能安装到硬盘。附：版本说明 制作启动盘U盘启动分为BIOS和UEFI两种方式 BIOS启动会展示老毛桃的更多菜单 UEFI模式只能选择PE进入安装系统会出现无法识别安装文件的问题，需要先查看U盘的盘符，然后修改配置指定盘符。开机进入安装选择界面，UEFI模式按e，BIOS模式按tab进入选项，修改如下：1vmlinuz initrd=initrd.img linux dd quiet 之后就会展示盘符，LABEL为CentOS的就是安装盘了，记下并重启，再次进入安装选项，修改如下：1vmlinuz initrd=initrd.img inst.stage2=hd:/dev/&lt;盘符&gt; quiet 安装完成后需要进行的工作 设置网络，默认未开启 配置yum以及各种源 安装各种软件frpc利用frpc实现内网穿透，通过外网访问内网服务配置frpc.ini，可以通过配置host_header_rewrite实现子域名访问服务，具体代码：1234567[nextcloud]type = httplocal_ip = 192.168.0.168local_port = 8080remote_port = 8780subdomain = nextcloudhost_header_rewrite = nextcloud.vpn.aizys.win:8780 nextcloud安卓APP官方正式版不支持自动上传历史图片，只能上传新增文件可下载github上的测试版实现，详细参考github","categories":[{"name":"Linux","slug":"Linux","permalink":"https://segmafrontend.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://segmafrontend.github.io/tags/Linux/"},{"name":"NAS","slug":"NAS","permalink":"https://segmafrontend.github.io/tags/NAS/"}]},{"title":"Apollo接入RN记录","slug":"Apollo接入RN记录","date":"2019-09-11T08:00:00.000Z","updated":"2021-05-27T07:52:46.617Z","comments":true,"path":"2019/09/11/Apollo接入RN记录/","link":"","permalink":"https://segmafrontend.github.io/2019/09/11/Apollo接入RN记录/","excerpt":"引入接入RN主要通过@apollo/react-hooks的ApolloProvider进行注册","text":"引入接入RN主要通过@apollo/react-hooks的ApolloProvider进行注册123456789101112import React from 'react';import &#123; ApolloProvider &#125; from '@apollo/react-hooks';import ApolloClient from './src/apollo/ApolloClient';import AppContainer from './src/router';export default () =&gt; &#123; return ( &lt;ApolloProvider client=&#123;ApolloClient&#125;&gt; &lt;AppContainer /&gt; &lt;/ApolloProvider&gt; );&#125;; 用@apollo/react-hoc的高阶组件graphql实现查询/突变并将结果注入RN组件123import &#123; graphql &#125; from '@apollo/react-hoc'；export default graphql(gql`...`)(component); 调试工具 JS调试，使用自带的Remote JS Debugging工具 样式调试，安装React Native Debugger 问题及解决方案 单个组件实现多个查询/突变，官方文档写的compose方法无法调用。查询源码发现最新版本代码已经移除了compost方法，需要自己写一个。 1234567891011compose(...funcs: Function[]) &#123; const functions = funcs.reverse(); return function(...args: any[]) &#123; const [firstFunction, ...restFunctions] = functions; let result = firstFunction.apply(null, args); restFunctions.forEach(fnc =&gt; &#123; result = fnc.call(null, result); &#125;); return result; &#125;;&#125; .graphql文件无法使用。由于RN没有使用webpack，无法通过loader读取。需要安装babel-plugin-import-graphql这个插件，这个插件使用export导出，引入方式和loader不同 1import &#123; customers &#125; from './login.graphql'; resolvers中引入的变量无法正常使用，且不报错。原因：不能使用和重名的变量，报错只能通过查询返回的props.data.error查看 1import &#123; customers as customersQuery &#125; from './login.graphql'; 本地resolvers处理带参数的查询，需要先不传参数获取所有结果，然后根据传入变量筛选后返回，readQuery的variables无法查询数组。","categories":[{"name":"Apollo","slug":"Apollo","permalink":"https://segmafrontend.github.io/categories/Apollo/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://segmafrontend.github.io/tags/Apollo/"},{"name":"React Native","slug":"React-Native","permalink":"https://segmafrontend.github.io/tags/React-Native/"}]},{"title":"Apollo接入Vue记录","slug":"Apollo接入Vue记录","date":"2019-09-06T08:00:00.000Z","updated":"2021-05-27T07:44:50.036Z","comments":true,"path":"2019/09/06/Apollo接入Vue记录/","link":"","permalink":"https://segmafrontend.github.io/2019/09/06/Apollo接入Vue记录/","excerpt":"经过试用，Apollo接入到Vue通过vue-apollo这个库实现，具体接入方式有三种： JS API Vue组件 Apollo组件","text":"经过试用，Apollo接入到Vue通过vue-apollo这个库实现，具体接入方式有三种： JS API Vue组件 Apollo组件 JS API实现方法： 单独文件创建ApolloClient实例，在main.js引入，同时在api文件中引入实例 通过.graphql写查询语句 123query HelloWorld &#123; hello&#125; 配置webpack读取.graphql文件 123456789101112// vue.config.jsmodule.exports = &#123; chainWebpack: config =&gt; &#123; // GraphQL Loader config.module .rule('graphql') .test(/\\.graphql$/) .use('graphql-tag/loader') .loader('graphql-tag/loader') .end() &#125;&#125; 使用ApolloClient实例的query方法新建查询，会返回一个Promise对象 12345// login.jsimport ApolloClient from './ApolloClient'import * as loginGql from './login.graphql'export const getHello = (params) =&gt; ApolloClient.query(&#123;query: loginGql.HelloWorld&#125;) 通过包装传入参数实现类axios效果 123import &#123; getHello &#125; from 'login.js'getHello().then().catch() 优点: 可以实现类似axios的封装，在vue组件和js代码中使用方法同axios，从axios迁移成本较低缺点: 通过ApolloClient实现查询，在vue组件中无法通过$apollo获取到查询相关信息，也就没法利用apollo的loading等特性 Vue组件新增数据后重新请求已更新本地缓存使用refetchQueries属性实现12345678910111213141516this.$apollo.mutate(&#123; // 查询语句 mutation: gql`mutation ($name: String!, $phone: String!) &#123; createCustomer(name: $name, phone: $phone) &#123; id name phone &#125; &#125;`, // 参数 variables: &#123; name: \"test\", phone: `189$&#123;Math.round(Math.random() * 100000000)&#125;` &#125;, refetchQueries: [&#123; query: loginGql.getCustomers &#125;] &#125;); 修改数据后自动更新缓存要求后台更新后返回新的数据对象，只要id/__typename能匹配上，就会自动更新，不然就只有在update字段中使用readQuery和writeQuery手动更新缓存123456789101112131415161718192021this.$apollo.mutate(&#123; // 查询语句 mutation: gql`mutation ($label: String!) &#123; addTag(label: $label) &#123; id label &#125; &#125;`, // 参数 variables: &#123; label: newTag, &#125;, update: (store, &#123; data: &#123; addTag &#125; &#125;) =&gt; &#123; // 从缓存中读取这个查询的数据 const data = store.readQuery(&#123; query: TAGS_QUERY &#125;) // 将变更中的标签添加到最后 data.tags.push(addTag) // 将数据写回缓存 store.writeQuery(&#123; query: TAGS_QUERY, data &#125;) &#125;&#125;","categories":[{"name":"Apollo","slug":"Apollo","permalink":"https://segmafrontend.github.io/categories/Apollo/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://segmafrontend.github.io/tags/Apollo/"},{"name":"Vue","slug":"Vue","permalink":"https://segmafrontend.github.io/tags/Vue/"}]},{"title":"Vue cli 3.0项目优化总结Vue Router懒加载+按需引入+高可用CDN","slug":"Vue CLI 3.0项目优化总结Vue Router懒加载+按需引入+高可用CDN","date":"2019-02-21T01:00:00.000Z","updated":"2023-10-26T01:11:32.842Z","comments":true,"path":"2019/02/21/Vue CLI 3.0项目优化总结Vue Router懒加载+按需引入+高可用CDN/","link":"","permalink":"https://segmafrontend.github.io/2019/02/21/Vue CLI 3.0项目优化总结Vue Router懒加载+按需引入+高可用CDN/","excerpt":"前言使用Vue.js构建的单页面应用（SPA - single page application），需要引入很多的库，包括自家的router、vuex等，第三方的axios、loadash等等，不做任何配置打包之后的文件就有10M+，在第一次载入页面的时候需要加载完整的应用代码，会出现长时间的白屏，用户体验极差。 我们的目标就是减少包体积、提升加载速度，同时保证可用性、维护性、不侵入业务代码。 具体的优化方法包括： Vue Router 懒加载 CDN引入依赖 第三方库按需引入 开启Gzip 关闭生产环境sourceMap","text":"前言使用Vue.js构建的单页面应用（SPA - single page application），需要引入很多的库，包括自家的router、vuex等，第三方的axios、loadash等等，不做任何配置打包之后的文件就有10M+，在第一次载入页面的时候需要加载完整的应用代码，会出现长时间的白屏，用户体验极差。 我们的目标就是减少包体积、提升加载速度，同时保证可用性、维护性、不侵入业务代码。 具体的优化方法包括： Vue Router 懒加载 CDN引入依赖 第三方库按需引入 开启Gzip 关闭生产环境sourceMap 诊断与验证既然我们要做优化，我们必须先知道从哪些方面下手，最后如何去验证我们优化的效果。 dist目录大小，最终打包的所有文件大小 webpack-bundle-analyzer，分析包中包含的模块的大小 浏览器调试工具，开启Disable Cache，查看客户端加载的资源大小以及速度 主要介绍一下webpack-bundle-analyzer，看官方介绍： This module will help you:&emsp;&emsp;1.Realize what’s really inside your bundle&emsp;&emsp;2.Find out what modules make up the most of its size&emsp;&emsp;3.Find modules that got there by mistake&emsp;&emsp;4.Optimize it! 效果图 使用方法Vue CLI 3 默认支持打包报告，其实就是webpack-bundle-analyzer这个插件，使用vue-cli-service build --report就会在dist目录下生成一个report.html，打开这个页面就可以看到分析报告了。 为了方便使用，我们可以在package.json的scripts下面新增一行：&quot;report&quot;: &quot;vue-cli-service build --report&quot;，这样就可以使用npm run report命令实现了。 PS：老版本的vue cli可以通过npm run build --report命令，打包完成后会自动打开分析页面 怎么看这个报告呢？其实很简单，每一个分区代表打包以后的一个js文件，不同的颜色代表了文件的大小，从大到小，分区里面会嵌套分区，表示包对应的子模块；左侧的菜单展示了每个js文件在stat（原始）、parsed（编译后）、gizpped（压缩后）三种情况的大小。 优化前后对比好不好，看疗效。我们先看结果再看过程。 优化前 dist目录大小为13.3MB 打包后的本地js文件(/dist/static/js/)： 浏览器请求到的js文件： webpack-bundle-analyzer：可以看到，实际请求时需要加载两个本地js文件一共1.95M，还有一个第三方js文件815kb，合计2.74M，用时接近10s（吐槽下公司网络）。 优化后 dist目录大小为2.95MB 打包后的本地js文件(/dist/static/js/)： 浏览器请求到的js文件： webpack-bundle-analyzer：可以看到，实际请求时请求了4个本地js文件一共156.5kb，CDN加载了6个包，一共207.5kb，合计364kb，用时2.2s，注意，优化后是包含了CDN资源的大小，网上很多网上都没有计算CDN的资源。对比优化前体积减少了87%，加载时间减少了78%（受网路影响，不太精确）。显而易见，优化效果非常显著，基本实现了秒开页面，用户体验杠杠滴！ 优化过程Vue Router 懒加载首先看官方文档，是这样描述懒加载的 当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。 实际操作非常简单，只需要把src/router.js中的组件引入方式从 1import Page404 from './src/Page404.vue'; 变更为1const page404 = () =&gt; import('./views/404.vue'); 就这样，over。当然，你想自定义分块也是可以的，通过 命名 chunk可以将多个组件打包到一个异步块中。 123const Foo = () =&gt; import(/* webpackChunkName: \"group-foo\" */ './Foo.vue')const Bar = () =&gt; import(/* webpackChunkName: \"group-foo\" */ './Bar.vue')const Baz = () =&gt; import(/* webpackChunkName: \"group-foo\" */ './Baz.vue') 最后的效果就是，打包后的js文件由之前的app.js和chunk-vendors.js多出了很多chunk，浏览器访问时会按需加载对应的chunk，从而减少了首屏的加载时间。 CDN引入依赖CDN引入依赖很简单，使用script标签引入对应的资源即可，但是存在几个问题： CDN服务器挂了怎么办？ 要是我们能检测到CDN是否成功就好了，当然能。常用的依赖包都会创建一个全局变量，通过检测这个环节变量就可以知道CDN的资源是否加载成功，不成功就加载服务器资源就可以了。缺点就是服务器上必须存放一份依赖包的备份，会增加包体积，但是并不影响访问速度。 怎么知道依赖包的全局变量呢？我们用axios举例，打开axios的Github的dist目录，可以看到axios.js和axios.min.js，我们要使用的是min包，但我们要在axios.js中去查找他的全局变量。其中有这样一段代码。 12345678if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' &amp;&amp; define.amd) define([], factory); else if(typeof exports === 'object') exports[\"axios\"] = factory(); else root[\"axios\"] = factory(); 我们就可以知道axios的全局变量就是axios了，在我们的publick/index.html中就可以这样检测 123&lt;!--引入axios--&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/axios@0.18.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt;window.axios || document.write('&lt;script src=\"&lt;%= BASE_URL %&gt;js/axios.min.js\"&gt;&lt;\\/script&gt;')&lt;/script&gt; 这样就实现了高可用的CDN引入依赖了，不怕挂！ 引入min包，没有了错误提醒，原有的业务代码中使用import引入的方式，CDN引入后无法使用了，维护两份代码？ 为了减小包体积提升速度，CDN需要引入min包，但是就损失依赖自带的错误提醒，只适用于生产环境，传统的做法就是维护两分代码，开发版使用完整包 或者import引入，生产环境引入min包，这对于一个懒人来说太麻烦了。 要是能这样就好了，业务代码使用import方式引入依赖，开发环境加载完整包，生产环境使用CDN加载min包，完美！但是，这可能吗？当然可能，使用webpack的externals+html-webpack-plugin就可以轻松搞定啦！ externals的作用就是在使用CDN的情况下，业务代码中仍然可以使用import引入依赖。官方文档是这样说的 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。 externals在vue.config.js中的配置webpack 1234567891011configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; config.externals = &#123; 'vue': 'Vue', 'vuex': 'Vuex', 'vue-router': 'VueRouter', 'axios': 'axios', 'vue-grid-layout': 'VueGridLayout' &#125;; &#125; &#125; 配置的格式：import包名: 全局变量，工作原理就是webpack在读取到import语句时会从externals中去查找对应的全局变量然后加载。比如&#39;vue-router&#39;: &#39;VueRouter&#39;，业务代码中使用import router from &#39;vue-router&#39;，webpack就会去查找VueRouter这个全局变量。 通过process.env.NODE_ENV === &#39;production&#39;判断生产环境才配置externals，开发环境仍然加载npm install安装的依赖，这样就解决了生产环境使用import引入读取CDN资源的问题，但是开发环境CDN资源仍然会加载，我们并不会用到，这种浪费浏览器资源的事情是不能容忍的，必须干掉！这时候就需要html-webpack-plugin登场了。 html-webpack-plugin在Vue CLI 中主要负责处理public/index.html，具体查看文档，在public/index.html中判断运行环境决定是否启用CDN。 12345&lt;% if (htmlWebpackPlugin.options.environment === 'production') &#123; %&gt;&lt;!--引入axios--&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/axios@0.18.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt;window.axios || document.write('&lt;script src=\"&lt;%= BASE_URL %&gt;js/axios.min.js\"&gt;&lt;\\/script&gt;')&lt;/script&gt;&lt;% &#125; %&gt; 这个environment并不是自带的，需要我们再vue.config.js中进行配置 123456789// 在htmlWebpackPlugin中增加环境变量，在index.html中使用 chainWebpack: config =&gt; &#123; config .plugin('html') .tap(args =&gt; &#123; args[0].environment = process.env.NODE_ENV; return args; &#125;); &#125; 至此，就实现高可用CDN的工程化了，不需要改业务代码，不需要开发环境生产环境两套代码，三分钟解决烦恼！ 第三方库按需引入都有了CDN了，为什么还需要按需引入呢？举个例子，项目中需要使用lodash的deepClone和isEqual两个方法，使用前面的方法引入loadash，虽然有CDN的加持，但是我们仍然需要加载lodash的完整包，为了两个方法就要加载完整包还是有些得不偿失的，这种情况按需引入可以获得更快的加载速度。 具体按需引入的方法，echarts、element-ui等官方文档都有说明，照着操作就可以了。 lodash的按需引入稍微麻烦一些，需要安装babel-plugin-lodash这个包 1npm install babel-plugin-lodash -D 然后配置babel.config.js 12345678module.exports = &#123; presets: [ ['@babel/env', &#123; 'targets': &#123; 'node': 6 &#125;&#125;] ], 'plugins': [ 'lodash' ]&#125;; 引用部分 12345678import lodash from 'lodash';const _lodash = &#123; cloneDeep: lodash.cloneDeep, isEqual: lodash.isEqual&#125;;window._ = _lodash; 只有通过lodash的.运算符调用的方法才会被引入 开启Gzipnginx的Gzip有两种方式，一种是服务器端的Gzip，这个大家都知道，就是每次请求时服务器先压缩再返回资源，对服务器性能有一定消耗；另一种是Gzip_static，就是打包时生成.gz文件，每次请求时服务器直接返回.gz文件，不消耗服务器性能。两种开启一种就可以了。 服务器端Gzip 很简单，只需要配置一下nginx的配置就可以了 12345678# 开启gzipgzip on;# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPUgzip_comp_level 5;# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩gzip_min_length 256;# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript; Gzip_static 需要安装compression-webpack-plugin实现打包为.gz文件，然后开启nginx的gzip_static让nginx优先查找文件的.gz版本发送给客户端。 1npm install compression-webpack-plugin -D vue.config.js中配置webpack 123456789101112const productionGzipExtensions = ['js', 'css']configureWebpack: &#123; plugins: [ new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp('\\\\.(' + productionGzipExtensions.join('|') + ')$'), threshold: 10240, minRatio: 0.8 &#125;) ] &#125; nginx配置 12# 开启gzip_staticgzip_static on; 其他配置 配置vue.config.js关闭生成环境的sourcemap 1productionSourceMap: false 减少不必要的第三方依赖 安装依赖区分开发模式，只在开发模式使用的依赖使用dev模式安装，例如 1npm install xxx --save-dev 总结优化是没有极限的，不同的项目需要采用不同的优化方案，没有最好的，只有最合适的。填坑之路很漫长，但是我相信，办法总比困难多。","categories":[{"name":"optimize","slug":"optimize","permalink":"https://segmafrontend.github.io/categories/optimize/"}],"tags":[]},{"title":"大文件上传解决方案","slug":"大文件上传解决方案","date":"2018-09-19T07:58:54.000Z","updated":"2023-10-26T01:13:26.622Z","comments":true,"path":"2018/09/19/大文件上传解决方案/","link":"","permalink":"https://segmafrontend.github.io/2018/09/19/大文件上传解决方案/","excerpt":"","text":"需求描述大数量文件上传 支持文件信息列表展示 每个文件校验格式、大小等信息 每个文件计算上传百分比、速度、剩余时间 大容量文件上传 支持断点续传 支持秒传 支持取消 准备工作上传文件夹大数量的文件上传都是通过上传文件夹的形式上传的，应该不会有人手动去选上万个文件的吧~so，首先需要用webkitdirectory来启动选择文件夹 1&lt;input type=\"file\" webkitdirectory&gt; HTML5 File APIFile API 提供了前端处理本地文件的能力，让图片预览、分块上传、拖拽上传等等神奇的操作变为可能。简单介绍一下我们会用到的部分，详细介绍看官方文档 FileList — input file标签获取到的值，是一个类数组，每个元素就是一个File对象。 File — FileList中的一个对象，包含文件的名称、大小、类别、修改时间等等基本信息。 FileReader — 文件读取的API，将文件读取到内存中，可以执行预览图片、计算MD5等等操作。 Blob — File对象就继承自Blob对象，二进制数据，提供操作接口，比如我们会用到的slice方法可以实现文件分块。 问题一：同时处理大量文件，浏览器直接崩溃？卡得要死？由于某些原因我们项目采用的单个文件依次上传的方式，上传部分就很简单了，只需要控制上传请求的数量就可以了，难点主要是对文件格式、大小的校验。 获取到文件列表并逐一处理如果我们直接用for循环取出每个文件进行处理，上万个文件同时加载可想而知，浏览器瞬间就投降了，这个时候就需要我们的Web Worker登场了，JavaScript主线程通过创建Worker线程，将一些计算密集型或高延迟型的任务交给Worker线程，充分发挥多核CPU的性能，避免主线程的阻塞和卡顿，下面简单介绍下如何使用，详细用法看Web Worker 使用教程 — 阮一峰 1234567891011121314let worker = new Worker('work.js');// 发送消息到work.jsworker.postMessage('Hello World');// 接收work.js传出的消息worker.onmessage = (e) =&gt; &#123; console.log(`Message：$&#123;e.data&#125;`); // do something...&#125;;// 捕获work.js中抛出的错误worker.onerror = (error) =&gt; &#123; console.log(`Error：$&#123;error&#125;`);&#125;;// 从主线程关闭workerworker.terminate(); 1234567891011121314151617181920// worker.js// 接收主线程传递的消息self.onmessage = (e) =&gt; &#123; console.log(`Data：$&#123;e.data&#125;`); // 这是个例子，具体怎么处理自由发挥 switch (e.data.cmd) &#123; case 'start': // 发送消息到主线程 self.postMessage('worker start'); // do something... break; case 'stop': self.postMessage('worker stop'); // 从子线程关闭worker self.close(); break; default: self.postMessage('Unknown command:'); &#125;&#125;; Web Worker可以理解为一个数据处理程序，传递一些消息或者数据给它，它会根据你设定的条件在需要的时候发送一个消息给你，你只需要监听对应的事件然后进行处理就好了。引入Web Worker后同时处理成千上万个文件的校验就不会引起浏览器的卡顿或者崩溃了，如果操作比较复杂，还可以多启动几个Worker来处理。、 问题二：大文读取MD5导致浏览器崩溃？我们项目最早使用的是JavaScript MD5(github传送门)，用于一些小文件的md5计算还可以，但是用于几百M的大文件就会出现浏览器卡顿、崩溃等问题，而且耗时较长。各种google之后发现了SparkMD5(github传送门)，SparkMD5是利用File API对文件进行分块之后进行的md5计算，效率很高，秒级运算而且不会引起浏览器的异常。示例代码： 123456789101112131415161718192021222324252627282930// 校验MD5 let blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice; let chunks = Math.ceil(file.size / chunkSize); let currentChunk = 0; let spark = new SparkMD5(); let fileReader = new FileReader(); const loadNext = () =&gt; &#123; let start = currentChunk * chunkSize; let end = ((start + chunkSize) &gt;= file.size) ? file.size : start + chunkSize; fileReader.readAsArrayBuffer(blobSlice.call(file, start, end)); &#125;; // fileReader.readAsBinaryString(file); fileReader.onload = function(e) &#123; // console.log('read chunk nr', currentChunk + 1, 'of', chunks); spark.append(e.target.result); currentChunk++; if (currentChunk &lt; chunks) &#123; loadNext(); &#125; else &#123; // console.log('finished loading'); // console.info('computed hash', spark.end()); // spark.end()返回的就是文件的md5值了 // 可以发送到服务器进行校验，从而实现秒传、续传等功能 &#125; &#125;; fileReader.onerror = function() &#123; console.warn('oops, something went wrong.'); &#125;; loadNext(); 问题三：如何实现分块上传、续传、秒传？有了md5以后这几个需求就很好实现了，md5相同的文件就可以认为是同一个文件，每个文件上传之前先发送文件的md5到服务器进行校验，服务器返回这个文件还有哪些分块缺失，前端再发送需要的分块到服务器即可。当然，前后端必须要提前约定分块大小才能保证最后能在后端拼凑成一个完整的文件。 服务器返回缺失部分分块就是续传了 服务器返回不缺失分块，就表示服务器上已经存在相同文件 ，前端显示秒传即可。 分块上传示例： 12345678910111213141516171819let chunkNum = 0; // 分块编号let chunkSize = 10 * 1024 * 1024; // 分块大小10Mlet chunks = Math.ceil(file.size / chunkSize); // 总分块数const uploadChunk = (chunkNum) =&gt; &#123; if (chunkNum &lt; chunks) &#123; let start = chunkNum * chunkSize; let stop = Math.min((start + chunkSize), file.size); let fileTip = file.slice(start, stop); upload(fileTip).then(() =&gt; &#123; chunkNum++; uploadChunk(chunkNum); &#125;).catch(&#123; // 错误处理 &#125;); &#125; else &#123; // 上传完成 &#125;&#125;;uploadChunk(chunkNum);","categories":[],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://segmafrontend.github.io/tags/文件上传/"}]},{"title":"JavaScript错误捕获相关总结","slug":"JavaScript错误捕获相关总结","date":"2018-09-19T02:00:00.000Z","updated":"2021-05-27T07:53:30.072Z","comments":true,"path":"2018/09/19/JavaScript错误捕获相关总结/","link":"","permalink":"https://segmafrontend.github.io/2018/09/19/JavaScript错误捕获相关总结/","excerpt":"try-catch ？try-catch的好处：增强代码的健壮性而不必影响程序的主逻辑，保持代码的简洁清晰","text":"try-catch ？try-catch的好处：增强代码的健壮性而不必影响程序的主逻辑，保持代码的简洁清晰 通常情况下，使用者（包括用户、代码库的使用者）所引发的错误，需要通过异常机制来处理。因为异常发生的时候，原订的执行流程就无法继续，但对于用户来讲，他们不能因为这样的错误就终止程序的使用，所以提供给程序设计者异常机制，让设计者决定发生意外的时候应该做些什么。而这种意外的产生原因是用户，用户的操作千千万万，导致的结果也可能千奇百怪，但是他们的操作若使得原有流程无法继续，那么就是异常。 楼主说的判断文件先存在，再读写文件，其实就是这个问题，按照程序的流程，可以保证在判断是否存在的时候，文件的存在性，但是不能保证在真正操作文件的时候文件的存在性（例如判断的时候文件还在，真正操作之前却被用户自己删掉了）。因为流程上无法对流程外的用户行为（用户删文件）作出保证，所以需要异常机制。 我认为，用户在程序运行时触发所导致的错误，需要异常机制来捕捉和处理。 作者：Blueve链接：https://www.zhihu.com/question/27122172/answer/35335950来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 try-catch用来处理可预知的异常可预知try-catch仅能用来处理可预知的错误，如： 楼主说的判断文件先存在，再读写文件，其实就是这个问题，按照程序的流程，可以保证在判断是否存在的时候，文件的存在性，但是不能保证在真正操作文件的时候文件的存在性（例如判断的时候文件还在，真正操作之前却被用户自己删掉了）。因为流程上无法对流程外的用户行为（用户删文件）作出保证，所以需要异常机制。如果catch到不可预知的错误，就无法合理处理错误，这时就需要throw到上一层，由上层统一处理。 处理try-catch后必须要处理错误，如果该错误无法处理，请不要使用try-catch，直接将error暴露给上层，由上层统一处理。不然会导致无法正常定位错误。反例：12345try &#123; doAnything();&#125; catch (e) &#123; // did nothing;&#125; promise.catch ?在一个promise链中，只要任何一个promise被reject，promise链就被破坏了，reject之后的promise都不会再执行，而是直接调用.catch方法。正确使用.catch有利于定位错误在promise链中的位置。处理示例：直接处理错误或将错误重新抛出为更高等级的错误12345678910111213// ....then((output) =&gt; &#123; return doAsyncOperation3();&#125;).catch((err) =&gt; &#123; // Re-throw the error as a higher-level error. // We will include the message from the lower-level // error as part of the error message for this error. throw new Error('Higher-level error. ' + err.message);&#125;).catch((err) =&gt; &#123; // In here we will get the higher-level error.&#125;) throw error ？从技术上将，我们可以throw任何类型值。但应尽量与内置对象达到兼容（throw有 name 和 message 属性的对象）。JavaScript 内置了许多标准错误对象类型：Error、SyntaxError、ReferenceError、TypeError 等 123let error = new Error(message);let error = new SyntaxError(message);let error = new ReferenceError(message); 对于内置的错误对象，name 属性正是对应构造函数名（如：Error,syntaxError,ReferenceError），message 属性值为传入的参数值。用例：12345678getAppname() &#123; if (this.pkg.name) &#123; debug('Loaded appname(%s) from package.json', this.pkg.name); return this.pkg.name; &#125; const pkg = path.join(this.options.baseDir, 'package.json'); throw new Error(`name is required from $&#123;pkg&#125;`); &#125; assert ? 程序设计中还有一种叫断言（ASSERT）的东西，这种机制是用来约束程序设计者的，例如某些库的某些函数，在文档中约定了，这个函数的参数必须是&gt;0，那么你在编程的时候愣是硬生生输入一个0，那么这时候就应该选择断言，用于帮助程序设计者及早的发现自己程序中的错误（这种错误是设计上的错误所引发的，而非用户的操作所导致的），而不是用异常机制去处理。所以，由程序员设计不足所导致的错误，需要用断言来捕捉和处理。 作者：Blueve链接：https://www.zhihu.com/question/27122172/answer/35335950来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 12345678910111213141516171819202122232425262728293031323334353637383940class ContextLoader extends FileLoader &#123; /** * @constructor * @param &#123;Object&#125; options - options same as &#123;@link FileLoader&#125; * @param &#123;String&#125; options.fieldClass - determine the field name of inject object. */ constructor(options) &#123; assert(options.property, 'options.property is required'); assert(options.inject, 'options.inject is required'); const target = options.target = &#123;&#125;; if (options.fieldClass) &#123; options.inject[options.fieldClass] = target; &#125; super(options); const app = this.options.inject; const property = options.property; // define ctx.service Object.defineProperty(app.context, property, &#123; get() &#123; // distinguish property cache, // cache's lifecycle is the same with this context instance // e.x. ctx.service1 and ctx.service2 have different cache if (!this[CLASSLOADER]) &#123; this[CLASSLOADER] = new Map(); &#125; const classLoader = this[CLASSLOADER]; let instance = classLoader.get(property); if (!instance) &#123; instance = getInstance(target, this); classLoader.set(property, instance); &#125; return instance; &#125;, &#125;); &#125;&#125;","categories":[{"name":"CodeReview","slug":"CodeReview","permalink":"https://segmafrontend.github.io/categories/CodeReview/"}],"tags":[{"name":"CodeReview","slug":"CodeReview","permalink":"https://segmafrontend.github.io/tags/CodeReview/"},{"name":"try-catch","slug":"try-catch","permalink":"https://segmafrontend.github.io/tags/try-catch/"},{"name":"throw","slug":"throw","permalink":"https://segmafrontend.github.io/tags/throw/"},{"name":"promise.catch","slug":"promise-catch","permalink":"https://segmafrontend.github.io/tags/promise-catch/"}]},{"title":"博客自动部署","slug":"博客自动部署","date":"2018-09-13T10:14:25.000Z","updated":"2021-05-27T07:44:50.039Z","comments":true,"path":"2018/09/13/博客自动部署/","link":"","permalink":"https://segmafrontend.github.io/2018/09/13/博客自动部署/","excerpt":"利用github的webHooks实现hexo项目的自动打包部署 准备工作 node.js，Git github/码云上创建hexo项目 一台云服务器/本地服务器，需要公网IP 一点后端代码和shell脚本","text":"利用github的webHooks实现hexo项目的自动打包部署 准备工作 node.js，Git github/码云上创建hexo项目 一台云服务器/本地服务器，需要公网IP 一点后端代码和shell脚本 服务器部署在服务器的项目目录下执行：1234$ npm install -g hexo-cli$ git clone 你的hexo项目git地址$ cd 你的项目名称$ npm install 设置webHooks钩子1、 登录github/码云，进入项目-管理-webHooks2、 添加/新增钩子，每次向这个项目push代码，就会触发这个钩子，像服务器发送一个请求，URL/POST地址设置为：1http://139.196.161.11:8080/hooks?password=yourpassword&amp;filename=你的shell脚本名称 3、 服务器端接受到请求传过来的filename参数，执行对应的shell脚本shell脚本主要代码：1234cd /xxx/你的项目名称git pullhexo ghexo d","categories":[{"name":"blog","slug":"blog","permalink":"https://segmafrontend.github.io/categories/blog/"}],"tags":[]},{"title":"markdown语法介绍","slug":"markdown","date":"2018-09-13T08:00:00.000Z","updated":"2021-05-27T07:44:50.038Z","comments":true,"path":"2018/09/13/markdown/","link":"","permalink":"https://segmafrontend.github.io/2018/09/13/markdown/","excerpt":"","text":"Author 果冻虾仁 E-mail Jelly.K.Wang@qq.com 目录 横线 标题 文本 普通文本 单行文本 多行文本 文字高亮 换行 斜体 粗体 删除线 图片 来源于网络的图片 GitHub仓库中的图片 链接 文字超链接 链接外部URL 链接本仓库里的URL 锚点 图片链接 列表 无序列表 有序列表 复选框列表 块引用 代码高亮 表格 表情 diff语法 横线 ***、—、___可以显示横线效果 标题一级标题二级标题三级标题四级标题五级标题六级标题文本普通文本这是一段普通的文本 单行文本Hello,大家好，我是果冻虾仁。 在一行开头加入1个Tab或者4个空格。 文本块语法1在连续几行的文本开头加入1个Tab或者4个空格。 欢迎到访 很高兴见到您 祝您，早上好，中午好，下午好，晚安 语法2使用一对各三个的反引号：123欢迎到访我是C++码农你可以在知乎、CSDN、简书搜索【果冻虾仁】找到我 该语法也可以实现代码高亮，见代码高亮 文字高亮文字高亮功能能使行内部分文字高亮，使用一对反引号。语法：1`linux` `网络编程` `socket` `epoll` 效果：linux 网络编程 socket epoll 也适合做一篇文章的tag 换行直接回车不能换行，可以在上一行文本后面补两个空格，这样下一行的文本就换行了。 或者就是在两行文本直接加一个空行。 也能实现换行效果，不过这个行间距有点大。 斜体、粗体、删除线 语法 效果 *斜体1* 斜体1 _斜体2_ 斜体2 **粗体1** 粗体1 __粗体2__ 粗体2 这是一个 ~~删除线~~ 这是一个 删除线 ***斜粗体1*** 斜粗体1 ___斜粗体2___ 斜粗体2 ***~~斜粗体删除线1~~*** 斜粗体删除线1 ~~***斜粗体删除线2***~~ 斜粗体删除线2 斜体、粗体、删除线可混合使用 图片基本格式：1![alt](URL title) alt和title即对应HTML中的alt和title属性（都可省略）： alt表示图片显示失败时的替换文本 title表示鼠标悬停在图片时的显示文本（注意这里要加引号） URL即图片的url地址，如果引用本仓库中的图片，直接使用相对路径就可了，如果引用其他github仓库中的图片要注意格式，即：仓库地址/raw/分支名/图片路径，如：1https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif # 语法 效果 1 ![baidu](http://www.baidu.com/img/bdlogo.gif &quot;百度logo&quot;) 2 ![][foryou] 注意例2的写法使用了URL标识符的形式，在链接一节有介绍。 在文末有foryou的定义：1[foryou]:https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif 链接链接外部URL # 语法 效果 1 [我的博客](http://blog.csdn.net/guodongxiaren &quot;悬停显示&quot;) 我的博客 2 [我的知乎][zhihu] 我的知乎 语法2由两部分组成： 第一部分使用两个中括号，[ ]里的标识符（本例中zhihu），可以是数字，字母等的组合，标识符上下对应就行了（姑且称之为URL标识符） 第二部分标记实际URL。 使用URL标识符能达到复用的目的，一般把全文所有的URL标识符统一放在文章末尾，这样看起来比较干净。 URL标识符是我起的名字，不知道是否准确。囧。。 链接本仓库里的URL 语法 效果 [我的简介](/example/profile.md) 我的简介 [example](./example) example 图片链接给图片加链接的本质是混合图片显示语法和普通的链接语法。普通的链接中[ ]内部是链接要显示的文本，而图片链接[ ]里面则是要显示的图片。直接混合两种语法当然可以，但是十分啰嗦，为此我们可以使用URL标识符的形式。 # 语法 效果 1 [![weibo-logo]](http://weibo.com/linpiaochen) 2 [![](/img/zhihu.png &quot;我的知乎，欢迎关注&quot;)][zhihu] 3 [![csdn-logo]][csdn] 因为图片本身和链接本身都支持URL标识符的形式，所以图片链接也可以很简洁（见例3）。注意，此时鼠标悬停时显示的文字是图片的title，而非链接本身的title了。 本文URL标识符都放置于文末 锚点其实呢，每一个标题都是一个锚点，和HTML的锚点（#）类似，比如我们 语法 效果 [回到顶部](#readme) 回到顶部 不过要注意，标题中的英文字母都被转化为小写字母了。 以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！ 列表无序列表 昵称：果冻虾仁 别名：隔壁老王 英文名：Jelly 多级无序列表 编程语言 脚本语言 Python 有序列表一般效果就是在数字后面加一个点，再加一个空格。不过看起来起来可能不够明显。面向对象的三个基本特征： 封装 继承 多态 多级有序列表和无序列表一样，有序列表也有多级结构： 这是一级的有序列表，数字1还是1 这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字 这是三级的有序列表，数字在显示的时候变成了英文字母 复选框列表 需求分析 系统设计 详细设计 编码 测试 交付 您可以使用这个功能来标注某个项目各项任务的完成情况。 Tip: 在GitHub的issue中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。 块引用常用于引用文本文本摘自《深入理解计算机系统》P27 令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。 “端”（endian）的起源以下是Jonathan Swift在1726年关于大小端之争历史的描述：“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。” 块引用有多级结构 数据结构 树 二叉树 平衡二叉树 满二叉树 代码高亮在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。1public static void main(String[]args)&#123;&#125; //Java 1int main(int argc, char *argv[]) //C 1echo \"hello GitHub\" #Bash 1document.getElementById(\"myH1\").innerHTML=\"Welcome to my Homepage\"; //javascipt 1string &amp;operator+(const string&amp; A,const string&amp; B) //cpp 表格 表头1 表头2 表格单元 表格单元 表格单元 表格单元 表头1 表头2 表格单元 表格单元 表格单元 表格单元 对齐表格可以指定对齐方式 左对齐 居中 右对齐 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 混合其他语法表格单元中的内容可以和其他大多数GFM语法配合使用，如： 使用普通文本的删除线，斜体等效果 名字 描述 Help Display the help window. Close Closes a window 表格中嵌入图片（链接）其实前面介绍图片显示、图片链接的时候为了清晰就是放在在表格中显示的。 图片 描述 百度 表情Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。 比如:blush:，可以显示:blush:。 具体每一个表情的符号码，可以查询GitHub的官方网页http://www.emoji-cheat-sheet.com。 但是这个网页每次都打开奇慢。。所以我整理到了本repo中，大家可以直接在此查看emoji。 diff语法版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。GFM中可以显示的展示diff效果。使用绿色表示新增，红色表示删除。 其语法与代码高亮类似，只是在三个反引号后面写diff，并且其内容中，以 +开头表示新增，-开头表示删除。 效果如下： 12+ 鸟宿池边树，僧敲月下门- 鸟宿池边树，僧推月下门","categories":[{"name":"blog","slug":"blog","permalink":"https://segmafrontend.github.io/categories/blog/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://segmafrontend.github.io/tags/markdown/"}]},{"title":"博客使用说明","slug":"博客使用说明","date":"2018-09-11T08:00:00.000Z","updated":"2021-05-27T07:22:41.769Z","comments":true,"path":"2018/09/11/博客使用说明/","link":"","permalink":"https://segmafrontend.github.io/2018/09/11/博客使用说明/","excerpt":"Hexo介绍Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 GFM（GitHub Flavored Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。","text":"Hexo介绍Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 GFM（GitHub Flavored Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 项目搭建安装Hexo1$ npm install -g hexo-cli 克隆项目1$ git clone https://gitee.com/cisdi/hexo.git 初始化项目12$ cd hexo$ npm install 快速开始新建一篇文章使用以下命令，或者在/source/_posts/目录下新建markdown文件参考：Hexo文档1$ hexo new \"My New Post\" 文章头部添加以下代码，配置文章选项(Front-matter)12345678---title: //标题date: //创建日期tags: [标签一,标签二]categories: //分类hidden：true/false //是否隐藏--- 在首页隐藏文章的大部分内容，加入以下代码，后面的代码将会在首页隐藏1&lt;!-- more --&gt; 运行服务，本地实时预览效果1$ hexo server 发布到服务器本项目已实现自动发布，推送后就会自动发布到西格马技术分享 如需手动发布可执行以下操作生成静态文件1$ hexo generate 或者简写1$ hexo g 部署到服务器1$ hexo deploy 或者简写1$ hexo d 如果更新没有生效请使用123$ hexo clean$ hexo g$ hexo d","categories":[{"name":"blog","slug":"blog","permalink":"https://segmafrontend.github.io/categories/blog/"}],"tags":[]},{"title":"CodeReview问题与总结第一期","slug":"CodeReview问题与总结第一期","date":"2018-09-11T08:00:00.000Z","updated":"2021-05-27T07:53:30.005Z","comments":true,"path":"2018/09/11/CodeReview问题与总结第一期/","link":"","permalink":"https://segmafrontend.github.io/2018/09/11/CodeReview问题与总结第一期/","excerpt":"常用的遍历方法有哪些？每种适用于什么场景，各有什么优缺点？","text":"常用的遍历方法有哪些？每种适用于什么场景，各有什么优缺点？ 常用遍历方法for循环语法： for (语句 1; 语句 2; 语句 3) { 被执行的代码块 }语句 1 在循环（代码块）开始前执行语句 2 定义运行循环（代码块）的条件语句 3 在循环（代码块）已被执行之后执行 for…infor...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。 语法： for (variable in object) {…} variable：在每次迭代时，将不同的属性名分配给变量。 object：被迭代枚举其属性的对象。 注意：for...in不应该用于迭代一个 Array for...in不仅可以遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。（即：for...in循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。） 不能保证for...in将以任何特定的顺序返回索引。 应用：12345var obj = &#123;a:1, b:2, c:3&#125;; for (var prop in obj) &#123; console.log(\"obj.\" + prop + \" = \" + obj[prop]);&#125; for…offor...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 语法： for (variable of iterable) { //statements } variable：在每次迭代中，将不同属性的值分配给变量。 iterable：可枚举其枚举属性的对象。 注意：可以使用break跳出循环应用：12345678910let iterable = [10, 20, 30]; for(let a of iterable)&#123; if(a &gt; 20) &#123; break &#125; console.log(a)&#125;// 10// 20 forEach()forEach方法对数组的每个元素执行一次提供的函数。语法： array.forEach(callback(currentValue, index, array){ //do something }, this) array.forEach(callback[, thisArg]) 参数： currentValue(当前值)：数组中正在处理的当前元素。 index(索引)：数组中正在处理的当前元素的索引。 array：forEach()方法正在操作的数组。 thisArg：可选参数。当执行回调 函数时用作this的值(参考对象)。 应用：1234//打印数组const arr = ['a', 'b', 'c'];arr.forEach( element =&gt; console.log(element)); 123456789101112131415//复制对象function copy(obj) &#123; var copy = Object.create(Object.getPrototypeOf(obj)); var propNames = Object.getOwnPropertyNames(obj); propNames.forEach(function(name) &#123; var desc = Object.getOwnPropertyDescriptor(obj, name); Object.defineProperty(copy, name, desc); &#125;); return copy;&#125;var obj1 = &#123; a: 1, b: 2 &#125;;var obj2 = copy(obj1); 缺点：不能中途跳出循环，如果数组在迭代时被修改了，则其他元素会被跳过。12345678910var words = [\"one\", \"two\", \"three\", \"four\"];words.forEach(function(word) &#123; console.log(word); if (word === \"two\") &#123; words.shift(); &#125;&#125;);// one// two// four map()map方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。语法： arr.map(function callback(currentValue, index, array) { // Return element for new_array }[, thisArg]) 参数： callback： 生成新数组元素的函数，使用三个参数：currentValue callback： 的第一个参数，数组中正在处理的当前元素。index callback： 的第二个参数，数组中正在处理的当前元素的索引。array callback： 的第三个参数，map方法被调用的数组。thisArg： 可选的。执行 callback 函数时 使用的this 值。 返回值：一个新数组，每个元素都是回调函数的结果。 应用：1234//重新格式化数组var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] 缺点： 不能中途跳出循环。 性能测试测试环境：node v9.8.0测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051测试环境：node v9.8.0JavaScriptvar number = 100; // array大小var array = [];for (let i = 0; i &lt; number; i++) &#123; array[i] = i + 1;&#125;var len = array.length;console.log('数组长度为：', number)// 正常for循环console.time('normal for');for (let i = 0; i &lt; len; i++) &#123; array[i] + 1;&#125;console.timeEnd('normal for');// 倒序for循环console.time('reverse for');for (let i = len - 1; i--;) &#123; array[i] + 1;&#125;console.timeEnd('reverse for');// while循环console.time('while');let i = 0;while (i &lt; len) &#123; array[i] + 1; i++;&#125;console.timeEnd('while');// for-in循环console.time('for-in');for (let i in array) &#123; array[i] + 1;&#125;console.timeEnd('for-in');// for each 循环console.time(\"for each\");array.forEach(e =&gt; e + 1);console.timeEnd(\"for each\")// map循环console.time(\"map\");array.map(e =&gt; e + 1);console.timeEnd(\"map\") 测试结果(ms为单位)： 数组长度 100 1000 10000 100000 1000000 普通for循环 0.101 0.125 0.343 0.224 4.778 倒序for循环 0.009 0.030 0.255 8.606 4.391 while循环 0.007 0.028 0.24 23.957 4.445 for-in 0.032 0.351 2.466 22.203 163.261 for-each 0.030 0.054 0.296 1.986 14.921 map 0.029 0.055 0.323 19.905 189.387 思考：我们选择循环的多个角度——业务需要、代码可读性、性能。小结： 多数情况下前端不会涉及到大数量级的运算，如果有，那么应该考虑业务代码的正确性或者是否该将运算交到后端处理，在小数据量的运算中优先考虑代码的可读性、可维护性：采用for-each和map方法。 延伸阅读： 为什么for-in效率相比而言这么低？for...in 一般是用在对象属性名的遍历上的，由于每次迭代操作会同时搜索实例本身的属性以及原型链上的属性，所以效率肯定低下。for-in实际上效率是最低的。这是因为 for...in有一些特殊的要求，具体包括： 遍历所有属性，不仅是 ownproperties 也包括原型链上的所有属性。 忽略 enumerable(可枚举) 为 false 的属性。 必须按特定顺序遍历，先遍历所有数字键，然后按照创建属性的顺序遍历剩下的。 相关链接：吹毛求疵的追求优雅高性能JavaScriptArray-MDN Vue是如何实现响应式的？监测变化时应注意什么？如何追踪变化当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 监测变化时应注意： Vue 不能检测到对象属性的添加或删除。 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 不能检测以下变动的数组: 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 相关链接：Vue细节与最佳实践Vue对象更改检测注意事项","categories":[{"name":"CodeReview","slug":"CodeReview","permalink":"https://segmafrontend.github.io/categories/CodeReview/"}],"tags":[{"name":"CodeReview","slug":"CodeReview","permalink":"https://segmafrontend.github.io/tags/CodeReview/"},{"name":"总结","slug":"总结","permalink":"https://segmafrontend.github.io/tags/总结/"}]},{"title":"git clone命令速度很慢解决方案","slug":"git-clone命令速度很慢解决方案","date":"2018-09-11T00:39:33.000Z","updated":"2021-05-27T07:22:41.768Z","comments":true,"path":"2018/09/11/git-clone命令速度很慢解决方案/","link":"","permalink":"https://segmafrontend.github.io/2018/09/11/git-clone命令速度很慢解决方案/","excerpt":"前言我们日常工作中使用git clone命令时速度非常慢，一个几M的项目都需要十几分钟，速度也就10kb/s-20kb/s，很让人着急，严重影响工作效率。这里提出一种解决方案，希望可以帮助大家解决烦恼","text":"前言我们日常工作中使用git clone命令时速度非常慢，一个几M的项目都需要十几分钟，速度也就10kb/s-20kb/s，很让人着急，严重影响工作效率。这里提出一种解决方案，希望可以帮助大家解决烦恼 准备工作 翻墙工具（SS、蓝灯之类，你懂的） 命令行工具 解决方案打开你的代理工具，找到本地代理的地址和端口，例如我的蓝灯： 方案1、打开命令行工具，输入12$ git config --global http.proxy http://127.0.0.1:52951$ git config --global https.proxy https://127.0.0.1:52951 方案2、或者编辑.gitconfig文件，windows系统在C:\\Users\\你的用户名这个文件夹下,mac用户执行1$ vi ~/.gitconfig 在文件最后添加1234[http] proxy = http://127.0.0.1:52951[https] proxy = https://127.0.0.1:52951 再试一下git clone，速度杠杠滴！总结工欲善其事必先利其器，简单的优化就能帮助我们提升开发效率！","categories":[{"name":"tool","slug":"tool","permalink":"https://segmafrontend.github.io/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"https://segmafrontend.github.io/tags/git/"}]}]}